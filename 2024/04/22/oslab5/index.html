<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Sidebar Display (only for Muse | Mist), available values":["always  expand for all pages automatically."],"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="title:SYSU-2024操作系统lab3实验报告 date:2024-04-28 23:54:26 tags:os comments:true author:zyh实验名称:          Lab5 内核线程学生姓名:                    庄云皓 学生学号:                   22336327 实验成绩: 报告时间:">
<meta property="og:type" content="article">
<meta property="og:title" content="yhzhuang">
<meta property="og:url" content="http://example.com/2024/04/22/oslab5/index.html">
<meta property="og:site_name" content="yhzhuang">
<meta property="og:description" content="title:SYSU-2024操作系统lab3实验报告 date:2024-04-28 23:54:26 tags:os comments:true author:zyh实验名称:          Lab5 内核线程学生姓名:                    庄云皓 学生学号:                   22336327 实验成绩: 报告时间:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714812925884.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714905739957.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714908742419.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714840614902.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714909688608.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714909446513.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714909863122.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714910381025.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714910209537.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714911275547.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714911725209.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714912484030.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714913439195.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714913635709.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714914114783.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714908659141.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714919664301.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714917101307.png">
<meta property="og:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714917971082.png">
<meta property="article:published_time" content="2024-04-22T03:06:50.967Z">
<meta property="article:modified_time" content="2024-05-06T03:09:22.849Z">
<meta property="article:author" content="zyh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/04/22/oslab5/oslab5/1714812925884.png">

<link rel="canonical" href="http://example.com/2024/04/22/oslab5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | yhzhuang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yhzhuang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>resources</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/22/oslab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-22 11:06:50" itemprop="dateCreated datePublished" datetime="2024-04-22T11:06:50+08:00">2024-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-06 11:09:22" itemprop="dateModified" datetime="2024-05-06T11:09:22+08:00">2024-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<p>title:SYSU-2024操作系统lab3实验报告</p>
<p>date:2024-04-28 23:54:26</p>
<p>tags:os</p>
<p>comments:true</p>
<h2 id="author-zyh"><a href="#author-zyh" class="headerlink" title="author:zyh"></a>author:zyh</h2><h1 id="实验名称-Lab5-内核线程"><a href="#实验名称-Lab5-内核线程" class="headerlink" title="实验名称:          Lab5 内核线程"></a>实验名称:          Lab5 内核线程</h1><p>学生姓名:                    庄云皓</p>
<p>学生学号:                   22336327</p>
<p>实验成绩:</p>
<p>报告时间:                   2023-5-5</p>
<h2 id="1-实验要求"><a href="#1-实验要求" class="headerlink" title="1. 实验要求"></a>1. <strong>实验要求</strong></h2><h3 id="Assignment-1-printf的实现"><a href="#Assignment-1-printf的实现" class="headerlink" title="Assignment 1 printf的实现"></a>Assignment 1 printf的实现</h3><p>学习可变参数机制，然后实现printf，你可以在材料中的printf上进行改进，或者从头开始实现自己的printf函数。结果截图并说说你是怎么做的。</p>
<h3 id="Assignment-2-线程的实现"><a href="#Assignment-2-线程的实现" class="headerlink" title="Assignment 2 线程的实现"></a>Assignment 2 线程的实现</h3><p>自行设计PCB，可以添加更多的属性，如优先级等，然后根据你的PCB来实现线程，演示执行结果。</p>
<h3 id="Assignment-3-线程调度切换的秘密"><a href="#Assignment-3-线程调度切换的秘密" class="headerlink" title="Assignment 3 线程调度切换的秘密"></a>Assignment 3 线程调度切换的秘密</h3><p>操作系统的线程能够并发执行的秘密在于我们需要中断线程的执行，保存当前线程的状态，然后调度下一个线程上处理机，最后使被调度上处理机的线程从之前被中断点处恢复执行。现在，同学们可以亲手揭开这个秘密。</p>
<p>编写若干个线程函数，使用gdb跟踪 <code>c_time_interrupt_handler</code>、<code>asm_switch_thread</code>等函数，观察线程切换前后栈、寄存器、PC等变化，结合gdb、材料中“线程的调度”的内容来跟踪并说明下面两个过程。</p>
<ul>
<li>一个新创建的线程是如何被调度然后开始执行的。</li>
<li>一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理机后又是如何从被中断点开始执行的。</li>
</ul>
<p>通过上面这个练习，同学们应该能够进一步理解操作系统是如何实现线程的并发执行的。</p>
<h3 id="（必做与选做）Assignment-4-调度算法的实现"><a href="#（必做与选做）Assignment-4-调度算法的实现" class="headerlink" title="（必做与选做）Assignment 4 调度算法的实现"></a>（必做与选做）Assignment 4 调度算法的实现</h3><p>在材料中，我们已经学习了如何使用时间片轮转算法来实现线程调度。但线程调度算法不止一种，例如</p>
<ul>
<li>先来先服务。</li>
<li>最短作业（进程）优先。</li>
<li>响应比最高者优先算法。</li>
<li>优先级调度算法。</li>
<li>多级反馈队列调度算法。</li>
</ul>
<p>此外，我们的调度算法还可以是抢占式的。</p>
<p>现在，同学们需要将线程调度算法修改为上面提到的算法或者是同学们自己设计的算法。然后，同学们需要自行编写测试样例来呈现你的算法实现的正确性和基本逻辑。最后，将结果截图并说说你是怎么做的。<strong>（先来先服务为必做，其他为选做）</strong></p>
<p>参考资料：<a href="https://gitee.com/link?target=https://zhuanlan.zhihu.com/p/97071815">https://zhuanlan.zhihu.com/p/97071815</a></p>
<p>Tips：</p>
<ul>
<li>先来先服务最简单。</li>
<li>有些调度算法的实现<strong>可能需要</strong>用到中断。</li>
</ul>
<h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2. 实验过程"></a>2. <strong>实验过程</strong></h2><h3 id="Assignment-1"><a href="#Assignment-1" class="headerlink" title="Assignment 1"></a>Assignment 1</h3><h4 id="1-1可变参数机制"><a href="#1-1可变参数机制" class="headerlink" title="1.1可变参数机制"></a>1.1可变参数机制</h4><p>实现这些宏</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>va_list</code></td>
<td>定义一个指向可变参数列表的指针。</td>
</tr>
<tr>
<td><code>void va_start(va_list ap, last_arg)</code></td>
<td>初始化可变参数列表指针 <code>ap</code>，使其指向可变参数列表的起始位置，即函数的固定参数列表的最后一个参数 <code>last_arg</code>的后面第一个参数。</td>
</tr>
<tr>
<td><code>type va_arg(va_list ap, type)</code></td>
<td>以类型 <code>type</code>返回可变参数，并使 <code>ap</code>指向下一个参数。</td>
</tr>
<tr>
<td><code>void va_end(va_list ap)</code></td>
<td>清零 <code>ap</code>。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, v) (ap = (va_list)&amp;v + _INTSIZEOF(v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, type) (*(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap = (va_list)0)</span></span><br></pre></td></tr></table></figure>

<p>注意这里的 _INTSIZIOF: ~(sizeof(int) - 1)为0xfffffffc ,任何地址与它&amp;后将低两位清零，为了实现向上对齐，我们需要先加上(sizeof(int)-1)后再和0xfffffffc相与，此时得到的结果就是向上4字节对齐的。</p>
<h4 id="1-2-实现printf增加-b和-f功能"><a href="#1-2-实现printf增加-b和-f功能" class="headerlink" title="1.2 实现printf增加%b和%f功能"></a>1.2 实现printf增加%b和%f功能</h4><p>实现了print(“%b,n),j和print(“%f”,n),分别将i以2进制和float浮点数，保留六位小数输出</p>
<p>让我们先解释一下printf实现的过程，我们需要用到可变参数机制，</p>
<p>解释一下printf中的代码：</p>
<p>如果 % 的下一个字符是’\0’，则退出；如果是’c’，则以字符的格式返回一个可变参数列表中的参数，并将其加入缓冲区；如果是’s’，则输出并清空缓冲区，并以char*的格式返回一个可变参数列表中的参数，并直接打印；如果是’d’，则以int的格式返回一个可变参数列表中的参数，转换为字符串后加入缓冲区；如果是’x’，则以int的格式返回一个可变参数列表中的参数，进行进制转换，然后转换为字符串，加入缓冲区；</p>
<p>%b的实现只需把%x中的itos(number, temp, (fmt[i] &#x3D;&#x3D; ‘d’ ? 10 : 16));改成itos(number, temp, (fmt[i] &#x3D;&#x3D; ‘d’ ? 10 : 2));</p>
<p>%f的实现参考了<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44078824/article/details/118440458">printf的实现</a></p>
<p>简单地说，先把浮点数分成整数部分和小数部分，然后将整数和小数分别转换为单个字符打印。因为是保留六位小数，小数先*1000000再按整数方式来打印，具体代码见关键代码部分</p>
<p>测试一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;print percentage: %%\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print char \&quot;N\&quot;: %c\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print string \&quot;Hello World!\&quot;: %s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print decimal: \&quot;-1234\&quot;: %d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print hexadecimal \&quot;0x7abcdef0\&quot;: %x\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print binary \&quot;0b10\&quot;: %b\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print float \&quot;3.1415\&quot;: %f\n&quot;</span>,</span><br><span class="line">           <span class="string">&#x27;N&#x27;</span>, <span class="string">&quot;Hello World!&quot;</span>, <span class="number">-1234</span>, <span class="number">0x7abcdef0</span>, <span class="number">0b10</span>,<span class="number">3.1415</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Assignment-2"><a href="#Assignment-2" class="headerlink" title="Assignment 2"></a>Assignment 2</h3><h4 id="线程的描述"><a href="#线程的描述" class="headerlink" title="线程的描述"></a>线程的描述</h4><p>先介绍一下进程控制块PCB:</p>
<p>在实验中用一个结构体表示，包括栈指针，线程名，状态，优先级，线程id等内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PCB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *stack;                      <span class="comment">// 栈指针，用于调度时保存esp</span></span><br><span class="line">    <span class="type">char</span> name[MAX_PROGRAM_NAME + <span class="number">1</span>]; <span class="comment">// 线程名</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ProgramStatus</span> status;       <span class="comment">// 线程的状态</span></span><br><span class="line">    <span class="type">int</span> priority;                    <span class="comment">// 线程优先级</span></span><br><span class="line">    <span class="type">int</span> pid;                         <span class="comment">// 线程pid</span></span><br><span class="line">    <span class="type">int</span> ticks;                       <span class="comment">// 线程时间片总时间</span></span><br><span class="line">    <span class="type">int</span> ticksPassedBy;               <span class="comment">// 线程已执行时间</span></span><br><span class="line">    ListItem tagInGeneralList;       <span class="comment">// 线程队列标识</span></span><br><span class="line">    ListItem tagInAllList;           <span class="comment">// 线程队列标识</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释几个变量的含义：<br>ticks是线程剩余的执行次数。在时间片调度算法中，每发生中断一次记为一个tick，当ticks&#x3D;0时，线程会被换下处理器，然后将其他线程换上处理器执行。</p>
<p>ticksPassedBy是线程总共执行的tick的次数。</p>
<p>tagInGeneralList和tagInAllList是线程在线程队列中的标识，用于在线程队列中找到线程的PCB。这两个变量的lListItem类型表示队列中的一个元素，是一个结构体，结构体中两个指针变量分别指向前面和后面的元素。用链表来实现进程队列，链表结构详见 ‘include&#x2F;list.h’</p>
<p>stack线程栈表示如下</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714812925884.png" alt="1714812925884"></p>
<p>对许多线程管理我们需要声明一个声明一个程序管理类 <code>ProgramManager.</code></p>
<p>用于线程和进程的创建和管理，代码见 <code>include/program.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROGRAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROGRAM_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProgramManager</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="线程的创建："><a href="#线程的创建：" class="headerlink" title="线程的创建："></a>线程的创建：</h4><p>1.我们在 <code>include/program.h</code>中对程序管理类 <code>ProgramManager</code>中的变量和函数进行声明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProgramManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    List allPrograms;   <span class="comment">// 所有状态的线程/进程的队列</span></span><br><span class="line">    List readyPrograms; <span class="comment">// 处于ready(就绪态)的线程/进程的队列</span></span><br><span class="line">    PCB *running;       <span class="comment">// 当前执行的线程</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProgramManager</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程并放入就绪队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// function：线程执行的函数</span></span><br><span class="line">    <span class="comment">// parameter：指向函数的参数的指针</span></span><br><span class="line">    <span class="comment">// name：线程的名称</span></span><br><span class="line">    <span class="comment">// priority：线程的优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功，返回pid；失败，返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">executeThread</span><span class="params">(ThreadFunction function, <span class="type">void</span> *parameter, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个PCB</span></span><br><span class="line">    <span class="function">PCB *<span class="title">allocatePCB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 归还一个PCB</span></span><br><span class="line">    <span class="comment">// program：待释放的PCB</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">releasePCB</span><span class="params">(PCB *program)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行线程调度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">schedule</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zu se huan xing</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MESA_WakeUp</span><span class="params">(PCB *program)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">program_exit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.向内存申请PCB空间（以下内容见src&#x2F;kernel&#x2F;program.cpp)</p>
<p>（1）声明PCB的空间和PCB分配状态数组</p>
<p>在内存中开辟一个PCB_SIZE * MAX_PROGRAM_AMOUNT个字节的空间用于分配给所有线程的thread-&gt;stack。这里我们把PCB大小设置为4096（4kb)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> PCB_SET[PCB_SIZE * MAX_PROGRAM_AMOUNT];<span class="comment">//MAX_PROGRAM_AMOUNT个PCB的大小空间</span></span><br></pre></td></tr></table></figure>

<p>再用一个bool类型数组表示PCB分配状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCB的分配状态，true表示已经分配，false表示未分配。</span></span><br><span class="line"><span class="type">bool</span> PCB_SET_STATUS[MAX_PROGRAM_AMOUNT];   </span><br></pre></td></tr></table></figure>

<p>如果已经给一个线程分配了PCB则将该线程对应的PCB_SET_STATUS中的数置1</p>
<p>（2）allocatePCB和releasePCB</p>
<p>具体进行分配的过程我们通过program_manager中的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个PCB</span></span><br><span class="line"><span class="function">PCB *<span class="title">allocatePCB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 归还一个PCB</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releasePCB</span><span class="params">(PCB *program)</span></span>;</span><br></pre></td></tr></table></figure>

<p>来实现。两个函数实现的代码放置在 <code>src/kernel/program.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PCB *<span class="title">ProgramManager::allocatePCB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PROGRAM_AMOUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PCB_SET_STATUS[i])</span><br><span class="line">        &#123;</span><br><span class="line">            PCB_SET_STATUS[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> (PCB *)((<span class="type">int</span>)PCB_SET + PCB_SIZE * i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数对PCB_SET_STATUS中的元素依次判断看该位置对应的PCB_SET空间是否已经被类配了，如果没有没有则返回第i个PCB的起始地址（对于第𝑖个PCB，<code>PCB_SET</code>的首地址加上<strong>i</strong>×<strong>P</strong>C<strong>B</strong>S<strong>I</strong>Z<strong>E</strong>𝑖×𝑃𝐶𝐵𝑆𝐼𝑍𝐸就是第<strong>i</strong>𝑖个PCB的起始地址）</p>
<p>有PCB的分配就有PCB的释放，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProgramManager::releasePCB</span><span class="params">(PCB *program)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = ((<span class="type">int</span>)program - (<span class="type">int</span>)PCB_SET) / PCB_SIZE;</span><br><span class="line">    PCB_SET_STATUS[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>releasePCB</code>接受一个PCB指针 <code>program</code>，然后计算出 <code>program</code>指向的PCB在 <code>PCB_SET</code>中的位置，然后将 <code>PCB_SET_STATUS</code>中的对应位置设置 <code>false</code>即可。</p>
<p>（3）excuteThread的实现</p>
<p>在这里我们规定线程只能执行返回值为void，参数为void *的函数<br>我们在include&#x2F;Program.h中将上面提到的这个函数定义为ThreadFunction。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*ThreadFunction)</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在ProgramManager类中声明一个用于创建线程的函数executeThread：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建一个线程并放入就绪队列</span></span><br><span class="line">    <span class="comment">// function：线程执行的函数</span></span><br><span class="line">    <span class="comment">// parameter：指向函数的参数的指针</span></span><br><span class="line">    <span class="comment">// name：线程的名称</span></span><br><span class="line">    <span class="comment">// priority：线程的优先级</span></span><br><span class="line">    <span class="comment">// 成功，返回pid；失败，返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">executeThread</span><span class="params">(ThreadFunction function, <span class="type">void</span> *parameter, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们在src&#x2F;kernel&#x2F;program.cpp中实现executeThread，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ProgramManager::executeThread</span><span class="params">(ThreadFunction function, <span class="type">void</span> *parameter, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 关中断，防止创建线程的过程被打断</span></span><br><span class="line">    <span class="type">bool</span> status = interruptManager.<span class="built_in">getInterruptStatus</span>();</span><br><span class="line">    interruptManager.<span class="built_in">disableInterrupt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一页作为PCB</span></span><br><span class="line">    PCB *thread = <span class="built_in">allocatePCB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!thread)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分配的页</span></span><br><span class="line">    <span class="built_in">memset</span>(thread, <span class="number">0</span>, PCB_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PROGRAM_NAME &amp;&amp; name[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;name[i] = name[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread-&gt;status = ProgramStatus::READY;</span><br><span class="line">    thread-&gt;priority = priority;</span><br><span class="line">    thread-&gt;ticks = priority * <span class="number">10</span>;</span><br><span class="line">    thread-&gt;ticksPassedBy = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;pid = ((<span class="type">int</span>)thread - (<span class="type">int</span>)PCB_SET) / PCB_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程栈</span></span><br><span class="line">    thread-&gt;stack = (<span class="type">int</span> *)((<span class="type">int</span>)thread + PCB_SIZE);</span><br><span class="line">    thread-&gt;stack -= <span class="number">7</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">4</span>] = (<span class="type">int</span>)function;</span><br><span class="line">    thread-&gt;stack[<span class="number">5</span>] = (<span class="type">int</span>)program_exit;</span><br><span class="line">    thread-&gt;stack[<span class="number">6</span>] = (<span class="type">int</span>)parameter;</span><br><span class="line"></span><br><span class="line">    allPrograms.<span class="built_in">push_back</span>(&amp;(thread-&gt;tagInAllList));</span><br><span class="line">    readyPrograms.<span class="built_in">push_back</span>(&amp;(thread-&gt;tagInGeneralList));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复中断</span></span><br><span class="line">    interruptManager.<span class="built_in">setInterruptStatus</span>(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thread-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在逐步地分析线程创建的逻辑。</p>
<p>（1）关中断</p>
<p>3-5行保存中断状态然后关中断，诸如PCB分配的工作实际上都需要进行线程互斥处理，我们在这里使用开关中断实现线程互斥为什么开&#x2F;关中断有效呢？在后面可以看到，我们是在时钟中断发生时来进行线程调度的，因此关中断后，时钟中断无法被响应，线程就无法被调度，直到再次开中断。只要线程无法被调度，那么线程的工作也就无法被其他线程打断，因此就实现了线程互斥。</p>
<p>关中断后，我们需要在函数返回前，也就是第44行恢复中断。</p>
<p>开&#x2F;关中断等相关的的函数定义在 <code>include/interrupt.h</code>中，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptManager</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开中断</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableInterrupt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关中断</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableInterrupt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取中断状态</span></span><br><span class="line">    <span class="comment">// 返回true，中断开启；返回false，中断关闭</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getInterruptStatus</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 设置中断状态</span></span><br><span class="line">    <span class="comment">// status=true，开中断；status=false，关中断</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInterruptStatus</span><span class="params">(<span class="type">bool</span> status)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数的实现比较简单，放置在 <code>src/interrupt/interrupt.cpp</code>中，这里便不再赘述，现在我们回到 <code>executeThread</code>。</p>
<p>（2）申请PCB空间，对PCB中的内容进行初始化</p>
<p>第8行，关中断后，我们向 <code>PCB_SET</code>申请一个线程的PCB，然后我们在第14行使用 <code>memeset</code>将PCB清0。<code>memeset</code>的声明和定义分别在 <code>include/stdlib.h</code>和 <code>src/utils/stdlib.cpp</code>。</p>
<p>第16-25行，我们设置PCB的成员 <code>name</code>、<code>status</code>、<code>priority</code>、<code>ticks</code>、<code>ticksPassedBy</code>和 <code>pid</code>。这里，线程初始的 <code>ticks</code>我们简单地设置为 <code>10</code>倍的 <code>priority</code>。<code>pid</code>则简单地使用PCB在 <code>PCB_SET</code>的位置来代替。</p>
<p>第28行，我们初始化线程的栈。我们将栈放置在PCB中，而线程的栈是从PCB的顶部开始向下增长的，所以不会与位于PCB低地址的 <code>name</code>和 <code>pid</code>等变量冲突。线程栈的初始地址是PCB的起始地址加上 <code>PCB_SIZE</code>。</p>
<p>第29-36行，我们在栈中放入7个整数值。</p>
<ul>
<li>4个为0的值是要放到ebp，ebx，edi，esi中的。</li>
<li><code>thread-&gt;stack[4]</code>是线程执行的函数的起始地址。</li>
<li><code>thread-&gt;stack[5]</code>是线程的返回地址，所有的线程执行完毕后都会返回到这个地址。</li>
<li><code>thread-&gt;stack[6]</code>是线程的参数的地址。</li>
</ul>
<p>至于这4部份的作用我们在线程的调度中统一讲解。</p>
<p>（3）将线程放进 <code>allPrograms</code>和 <code>readyPrograms</code></p>
<p>创建完线程的PCB后，我们将其放入到 <code>allPrograms</code>和 <code>readyPrograms</code>中，等待时钟中断来的时候，这个新创建的线程就可以被调度上处理器。</p>
<p>（4)开中断</p>
<p>最后我们将中断的状态恢复，此时我们便创建了一个线程。</p>
<h3 id="Assignment-3"><a href="#Assignment-3" class="headerlink" title="Assignment 3"></a>Assignment 3</h3><h4 id="3-1一个新创建的线程是如何被调度然后开始执行"><a href="#3-1一个新创建的线程是如何被调度然后开始执行" class="headerlink" title="3.1一个新创建的线程是如何被调度然后开始执行?"></a>3.1一个新创建的线程是如何被调度然后开始执行?</h4><p>我们来看setup.cpp中调用的汇编函数asm_switch_thread(0, firstThread);<br>将参数和返回地址压栈后，我们将 <code>ebp</code>，<code>ebx</code>，<code>edi</code>，<code>esi</code> 依次压栈（因为这几个存器的值可能会在被调函数中被修改，要先保护起来）。现在的栈状态如下：</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714905739957.png" alt="1714905739957"></p>
<p>29行[esp+5 * 4]表示PCB * cur这个指针变量的值（也就是指向空间的地址），把它赋值给eax。32行[esp+6 * 4]则是PCB *next.</p>
<p>注意30行保存当前栈指针esp到PCB::stack中.[eax]就是PCB * cur这个指针变量的值, 因为PCB第一个变量就是int <em><em>stack,[eax]其实就是</em>PCB::stack所在地址(int*)((int)thread+PCB_SIZE)-7</em></p>
<p><em>下面32-33行我们将PCB</em> next值写入eax,将next-&gt;stack的值写入esp<br>也就是说，现在esp由原来线程的stack切换为了next-&gt;stack.</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714908742419.png" alt="1714908742419"></p>
<p>通过调试过程来具体观察一下：<br>初始时esp为0x7bc0,</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714840614902.png" alt="1714840614902"></p>
<p>33行之后，可以看到esp的值变成了thread1的stack的地址,接着36行到39行弹出thread1的栈中内容（全都是0）到四个寄存器中。因为现在的esp已经变成了thread1的stack,返回地址也是函数first_thread的首地址。ret执行后就跳转到了first_thread函数。（如下图所示，先pop4个0到寄存器，然后返回，返回地址是function的地址）</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714909688608.png" alt="1714909688608"><br><img src="/2024/04/22/oslab5/oslab5/1714909446513.png" alt="1714909446513"><br>然后我们便进入了first_thread<br><img src="/2024/04/22/oslab5/oslab5/1714909863122.png" alt="1714909863122"></p>
<h4 id="3-2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的"><a href="#3-2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的" class="headerlink" title="3.2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的?"></a>3.2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的?</h4><p>现在我们着重关注RR时间片轮转调度的过程，首先在中断处理函数处设置断点：</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714910381025.png" alt="1714910381025"></p>
<p>观察cur-&gt;ticks和cur-&gt;ticksPassedBy的变化<br><img src="/2024/04/22/oslab5/oslab5/1714910209537.png" alt="1714910209537"></p>
<p>每一次发生时钟中断时，中断处理函数都会将当前进程PCB的ticks-1,ticksPassedBy+1,当cur-&gt;ticks为0时进行进程切换。</p>
<p>接下来我们观察这个进程如何被换下处理器。时间片用完后进行调度，进入schedule函数内部，因为当前进程还在运行，我们把它放在ready队列的队尾，并将ticks重置。</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714911275547.png" alt="1714911275547"></p>
<p>接着获取ready队列的头一个元素，简单做一些变量的修改后，把ready队列头pop出来，接着我们又进入了asm_swith_thread(cur,next)</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714911725209.png" alt="1714911725209"></p>
<p>进行线程栈的切换，ret后返回second_thread.</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714912484030.png" alt="1714912484030"></p>
<p>thread1已经被换下处理器了，thread1下一次被换上处理器是具体如何执行的呢?</p>
<p>thread3的时间片用完以后，进入scedule函数，调用asm_swith_thread(cur,next),此时的next指向的是thread1,因为thread1已经不是新的进程了，此时它的ebp不为0.</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714913439195.png" alt="1714913439195"></p>
<p>注意到，这里函数返回地址132695是schedule函数中调用asm_swith_thread(cur,next)语句的地址，调用完该函数后返回原来位置。然后schedule函数执行完，继续执行完他所在的c_time_interrupt_handle后返回asm_time_interrupt_handle，该函数iret后返回了thread1执行到的位置，也就是asm_halt中的死循环。</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714913635709.png" alt="1714913635709"></p>
<p><img src="/2024/04/22/oslab5/oslab5/1714914114783.png" alt="1714914114783"></p>
<h3 id="Assignment-4"><a href="#Assignment-4" class="headerlink" title="Assignment 4"></a>Assignment 4</h3><p>4.1FIFO</p>
<p>相比于assignment23修改了：</p>
<p>c_time_interrupt_handler()中把队cur-&gt;ticks的处理全都去掉</p>
<p>线程都没有死循环</p>
<p>void program_exit()中如果ready队列非空则进行调度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!programManager.readyPrograms.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    programManager.<span class="built_in">schedule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果见实验结果</p>
<p>4.1优先级调度</p>
<p>在ProgramManager::schedule()函数中找当前ready队列优先级最大的任务，具体代码见关键代码部分</p>
<p>将thread1,2,3的优先级分别设置为1,2,3,那么会依次执行thread3,2,1,结果见实验结果部分</p>
<h2 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3. 关键代码"></a>3. <strong>关键代码</strong></h2><h3 id="Assignment1"><a href="#Assignment1" class="headerlink" title="Assignment1"></a>Assignment1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// 接收浮点型 保留6为小数，不采取四舍五入</span></span><br><span class="line">                <span class="type">float</span> ArgFloVal = <span class="built_in">va_arg</span>(ap, <span class="type">double</span>);</span><br><span class="line">                <span class="keyword">if</span> (ArgFloVal &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, <span class="string">&#x27;-&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    ArgFloVal = -ArgFloVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> val_seg = (<span class="type">unsigned</span> <span class="type">long</span>)ArgFloVal;<span class="comment">// 取整数部分</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> val_temp = val_seg;      <span class="comment">// 临时保存整数部分数据</span></span><br><span class="line">                ArgFloVal = ArgFloVal - val_seg;<span class="comment">// 得出余下的小数部分</span></span><br><span class="line">                <span class="comment">// 计算整数部分长度</span></span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (val_seg)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (val_seg) &#123;</span><br><span class="line">                        cnt++;</span><br><span class="line">                        val_seg /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt = <span class="number">1</span>;<span class="comment">// 数字0的长度为1</span></span><br><span class="line">                <span class="comment">//counter += cnt;// 字符个数加上整数的长度</span></span><br><span class="line">                <span class="comment">// 将整数转为单个字符打印</span></span><br><span class="line">                <span class="keyword">while</span> (cnt)</span><br><span class="line">                &#123;</span><br><span class="line">                    val_seg = val_temp / <span class="built_in">m_pow_n</span>(<span class="number">10</span>, cnt - <span class="number">1</span>);</span><br><span class="line">                    val_temp %= <span class="built_in">m_pow_n</span>(<span class="number">10</span>, cnt - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//my_send_char((char)val_seg + &#x27;0&#x27;);</span></span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, (<span class="type">char</span>)val_seg + <span class="string">&#x27;0&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印小数点</span></span><br><span class="line">                counter += <span class="built_in">printf_add_to_buffer</span>(buffer,<span class="string">&#x27;.&#x27;</span>, idx, BUF_LEN);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开始输出小数部分</span></span><br><span class="line">                ArgFloVal *= <span class="number">1000000</span>;</span><br><span class="line">                <span class="comment">// printf(&quot;\r\n %f\r\n&quot;, ArgFloVal);</span></span><br><span class="line">                cnt = <span class="number">6</span>;</span><br><span class="line">                val_temp = (<span class="type">int</span>)ArgFloVal;<span class="comment">// 取整数部分</span></span><br><span class="line">                <span class="keyword">while</span> (cnt)</span><br><span class="line">                &#123;</span><br><span class="line">                    val_seg = val_temp / <span class="built_in">m_pow_n</span>(<span class="number">10</span>, cnt - <span class="number">1</span>);</span><br><span class="line">                    val_temp %= <span class="built_in">m_pow_n</span>(<span class="number">10</span>, cnt - <span class="number">1</span>);</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, (<span class="type">char</span>)val_seg + <span class="string">&#x27;0&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    <span class="comment">//my_send_char((char)val_seg + &#x27;0&#x27;);</span></span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//ret_num += 6;</span></span><br><span class="line">                <span class="comment">//pStr++;</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:&#123;</span><br><span class="line">             <span class="type">int</span> temp = <span class="built_in">va_arg</span>(ap, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, <span class="string">&#x27;-&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    temp = -temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">itos</span>(number, temp, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; number[j]; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, number[j], idx, BUF_LEN);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:&#123;</span><br><span class="line">                <span class="type">int</span> temp = <span class="built_in">va_arg</span>(ap, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span> &amp;&amp; fmt[i] == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, <span class="string">&#x27;-&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    temp = -temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">itos</span>(number, temp, (fmt[i] == <span class="string">&#x27;d&#x27;</span> ? <span class="number">10</span> : <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; number[j]; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, number[j], idx, BUF_LEN);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Assignment3"><a href="#Assignment3" class="headerlink" title="Assignment3"></a>Assignment3</h3><p>代码的解释见实验过程部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">asm_switch_thread:</span><br><span class="line">    push ebp</span><br><span class="line">    push ebx</span><br><span class="line">    push edi</span><br><span class="line">    push esi</span><br><span class="line"></span><br><span class="line">    mov eax, [esp + 5 * 4]</span><br><span class="line">    mov [eax], esp ; 保存当前栈指针到PCB中，以便日后恢复</span><br><span class="line"></span><br><span class="line">    mov eax, [esp + 6 * 4]</span><br><span class="line">    mov esp, [eax] ; 此时栈已经从cur栈切换到next栈</span><br><span class="line"></span><br><span class="line">    pop esi</span><br><span class="line">    pop edi</span><br><span class="line">    pop ebx</span><br><span class="line">    pop ebp</span><br><span class="line"></span><br><span class="line">    sti</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h3 id="Assignment-4-1"><a href="#Assignment-4-1" class="headerlink" title="Assignment 4"></a>Assignment 4</h3><p>优先级调度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProgramManager::schedule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> status = interruptManager.<span class="built_in">getInterruptStatus</span>();</span><br><span class="line">    interruptManager.<span class="built_in">disableInterrupt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readyPrograms.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        interruptManager.<span class="built_in">setInterruptStatus</span>(status);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (running-&gt;status == ProgramStatus::RUNNING)</span><br><span class="line">    &#123;</span><br><span class="line">        running-&gt;status = ProgramStatus::READY;</span><br><span class="line">        running-&gt;ticks = running-&gt;priority * <span class="number">10</span>;</span><br><span class="line">        readyPrograms.<span class="built_in">push_back</span>(&amp;(running-&gt;tagInGeneralList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (running-&gt;status == ProgramStatus::DEAD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">releasePCB</span>(running);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化max,next,nextid,ready队列的size</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">    PCB* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> nextid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = readyPrograms.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//找到优先级最大的线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        ListItem* item = readyPrograms.<span class="built_in">at</span>(i);</span><br><span class="line">        PCB* tmp = <span class="built_in">ListItem2PCB</span>(item, tagInGeneralList);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;priority &gt; max)&#123;</span><br><span class="line">            max = tmp-&gt;priority;</span><br><span class="line">            nextid = i;</span><br><span class="line">            next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ListItem *item = readyPrograms.front();</span></span><br><span class="line">    <span class="comment">//PCB *next = ListItem2PCB(item, tagInGeneralList);</span></span><br><span class="line">    <span class="comment">//从ready队列中取出，将该线程状态置为running</span></span><br><span class="line">    PCB *cur = running;</span><br><span class="line">    next-&gt;status = ProgramStatus::RUNNING;</span><br><span class="line">    running = next;</span><br><span class="line">    readyPrograms.<span class="built_in">erase</span>(nextid);</span><br><span class="line">    <span class="comment">//切换线程栈，实现线程的切换</span></span><br><span class="line">    <span class="built_in">asm_switch_thread</span>(cur, next);</span><br><span class="line"></span><br><span class="line">    interruptManager.<span class="built_in">setInterruptStatus</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. <strong>实验结果</strong></h2><h4 id="Assignment1-1"><a href="#Assignment1-1" class="headerlink" title="Assignment1:"></a>Assignment1:</h4><p>printf %b（二进制）和%f(保留六位小数)</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714908659141.png" alt="1714908659141"></p>
<h4 id="Assignment2"><a href="#Assignment2" class="headerlink" title="Assignment2:"></a>Assignment2:</h4><p><img src="/2024/04/22/oslab5/oslab5/1714919664301.png" alt="1714919664301"></p>
<h4 id="Assignment3-1"><a href="#Assignment3-1" class="headerlink" title="Assignment3:"></a>Assignment3:</h4><p>见实验过程部分</p>
<h4 id="Assignment4"><a href="#Assignment4" class="headerlink" title="Assignment4:"></a>Assignment4:</h4><p>4.1 FIFO</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714917101307.png" alt="1714917101307"></p>
<p>4.2 优先级调度</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714917971082.png" alt="1714917971082"></p>
<h2 id="5-实验总结"><a href="#5-实验总结" class="headerlink" title="5.实验总结"></a>5.实验总结</h2><p>通过这次实验，学习了可变参数机制，并增添了实验中的pringf函数的功能，线程在操作系统中的描述，调度方式。复现实验很容易，但要深入理解其中的每一处细节并准确描述出来很难。我在Assignment3中开始由于对函数调用过程中栈的变化不熟悉卡了很久，后来看到其他同学的解释时才更加深入理解了 <code>asm_switch_thread</code>的设计,感受到了设计的巧妙之处。</p>
<!--在src/kernel/pragram.cpp文件中，传参为nullptr的作用？

为什么会返回schedule-->

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/04/07/oslab3/" rel="prev" title="SYSU-2024操作系统lab3实验">
      <i class="fa fa-chevron-left"></i> SYSU-2024操作系统lab3实验
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/06/oslab6/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#author-zyh"><span class="nav-number">1.</span> <span class="nav-text">author:zyh</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%90%8D%E7%A7%B0-Lab5-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">实验名称:          Lab5 内核线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="nav-number">1.</span> <span class="nav-text">1. 实验要求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment-1-printf%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.</span> <span class="nav-text">Assignment 1 printf的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text">Assignment 2 线程的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment-3-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%87%E6%8D%A2%E7%9A%84%E7%A7%98%E5%AF%86"><span class="nav-number">1.3.</span> <span class="nav-text">Assignment 3 线程调度切换的秘密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E5%BF%85%E5%81%9A%E4%B8%8E%E9%80%89%E5%81%9A%EF%BC%89Assignment-4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.4.</span> <span class="nav-text">（必做与选做）Assignment 4 调度算法的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">2. 实验过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment-1"><span class="nav-number">2.1.</span> <span class="nav-text">Assignment 1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1可变参数机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%AE%9E%E7%8E%B0printf%E5%A2%9E%E5%8A%A0-b%E5%92%8C-f%E5%8A%9F%E8%83%BD"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.2 实现printf增加%b和%f功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment-2"><span class="nav-number">2.2.</span> <span class="nav-text">Assignment 2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.2.1.</span> <span class="nav-text">线程的描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%9A"><span class="nav-number">2.2.2.</span> <span class="nav-text">线程的创建：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment-3"><span class="nav-number">2.3.</span> <span class="nav-text">Assignment 3</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1%E4%B8%80%E4%B8%AA%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E8%B0%83%E5%BA%A6%E7%84%B6%E5%90%8E%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C"><span class="nav-number">2.3.1.</span> <span class="nav-text">3.1一个新创建的线程是如何被调度然后开始执行?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%84%B6%E5%90%8E%E8%A2%AB%E6%8D%A2%E4%B8%8B%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%8D%A2%E4%B8%8A%E5%A4%84%E7%90%86%E5%99%A8%E5%90%8E%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E4%BB%8E%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%82%B9%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="nav-number">2.3.2.</span> <span class="nav-text">3.2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment-4"><span class="nav-number">2.4.</span> <span class="nav-text">Assignment 4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81"><span class="nav-number">3.</span> <span class="nav-text">3. 关键代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment1"><span class="nav-number">3.1.</span> <span class="nav-text">Assignment1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment3"><span class="nav-number">3.2.</span> <span class="nav-text">Assignment3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assignment-4-1"><span class="nav-number">3.3.</span> <span class="nav-text">Assignment 4</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">4.</span> <span class="nav-text">4. 实验结果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Assignment1-1"><span class="nav-number">4.0.1.</span> <span class="nav-text">Assignment1:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Assignment2"><span class="nav-number">4.0.2.</span> <span class="nav-text">Assignment2:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Assignment3-1"><span class="nav-number">4.0.3.</span> <span class="nav-text">Assignment3:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Assignment4"><span class="nav-number">4.0.4.</span> <span class="nav-text">Assignment4:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">5.实验总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
