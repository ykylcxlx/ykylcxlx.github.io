<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","Sidebar Display (only for Muse | Mist), available values":["always  expand for all pages automatically."],"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="yhzhuang">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="yhzhuang">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zyh">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>yhzhuang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">yhzhuang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>resources</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/12/oslab9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/12/oslab9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-12 10:40:15" itemprop="dateCreated datePublished" datetime="2024-07-12T10:40:15+08:00">2024-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-13 17:23:09" itemprop="dateModified" datetime="2024-07-13T17:23:09+08:00">2024-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实验课程:                   操作系统</p>
<h1 id="实验名称-Lab9-malloc-free"><a href="#实验名称-Lab9-malloc-free" class="headerlink" title="实验名称:          Lab9 malloc-free"></a><strong>实验名称:          Lab9 malloc-free</strong></h1><ul>
<li>学生姓名:                    庄云皓</li>
<li>学生学号:                   22336327</li>
</ul>
<h2 id="1-实验要求"><a href="#1-实验要求" class="headerlink" title="1. 实验要求"></a>1. <strong>实验要求</strong></h2><p>实现系统调用malloc和free。malloc用于分配任意字节的内存，free用于释放任意字节的内存。</p>
<p>按照教程中给的代码复现实验，并对加入同步互斥代码以保证保证动态内存分配时的线程安全。</p>
<h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2. 实验过程"></a>2. <strong>实验过程</strong></h2><p><strong>基本思路</strong></p>
<p>分配𝑠𝑖𝑧𝑒个字节的内存时的时候，我们需要找到一个𝑁，满足2^(𝑁−1)&lt;𝑠𝑖𝑧𝑒≤2^𝑁</p>
<p>也就是从小到大搜索，找到第一个恰好不小于𝑠𝑖𝑧𝑒的arena。找到这样一个arena后，我们便返回arena的起始地址作为分配的结果。特别地，当没有arena能够包含𝑠𝑖𝑧𝑒个字节时，我们就分配连续的𝑀个页，使得(𝑀−1)×4096&lt;𝑠𝑖𝑧𝑒≤𝑀×4096</p>
<p>返回这𝑀个页的起始地址作为分配的结果。</p>
<p><strong>过程</strong></p>
<p>先在setup函数中设置两个系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置4号系统调用</span></span><br><span class="line">systemService.<span class="built_in">setSystemCall</span>(<span class="number">4</span>, (<span class="type">int</span>)syscall_malloc);</span><br><span class="line"><span class="comment">//设置5号系统调用</span></span><br><span class="line">systemService.<span class="built_in">setSystemCall</span>(<span class="number">5</span>, (<span class="type">int</span>)syscall_free);</span><br></pre></td></tr></table></figure>

<p>在system_call.cpp中加入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">malloc</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)<span class="built_in">asm_system_call</span>(<span class="number">4</span>,size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span>* address)</span></span>&#123;</span><br><span class="line">    <span class="built_in">asm_system_call</span>(<span class="number">5</span>,(<span class="type">int</span>)address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着我们需要完善这两个系统调用函数：</p>
<p><code>void* syscall_malloc(intsize)</code>和 <code>void syscall_free(void*address)</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">syscall_malloc</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PCB *pcb = programManager.running;</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;pageDirectoryAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每一个进程有自己的ByteMemoryManager</span></span><br><span class="line">        <span class="keyword">return</span> pcb-&gt;byteMemoryManager.<span class="built_in">allocate</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 所有内核线程共享一个ByteMemoryManager</span></span><br><span class="line">        <span class="keyword">return</span> kernelByteMemoryManager.<span class="built_in">allocate</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">syscall_free</span><span class="params">(<span class="type">void</span> *address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PCB *pcb = programManager.running;</span><br><span class="line">    <span class="keyword">if</span> (pcb-&gt;pageDirectoryAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        pcb-&gt;byteMemoryManager.<span class="built_in">release</span>(address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        kernelByteMemoryManager.<span class="built_in">release</span>(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在memory.h中定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MemoryManager是在内核态调用的内存管理对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ByteMemoryManager</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 16, 32, 64, 128, 256, 512, 1024</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MEM_BLOCK_TYPES = <span class="number">7</span>;       <span class="comment">// 内存块的类型数目</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> minSize = <span class="number">16</span>;              <span class="comment">// 内存块的最小大小</span></span><br><span class="line">    <span class="type">int</span> arenaSize[MEM_BLOCK_TYPES];             <span class="comment">// 每种类型对应的内存块大小</span></span><br><span class="line">    MemoryBlockListItem *arenas[MEM_BLOCK_TYPES]; <span class="comment">// 每种类型的arena内存块的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ByteMemoryManager</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">int</span> size)</span></span>;  <span class="comment">// 分配一块地址</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(<span class="type">void</span> *address)</span></span>; <span class="comment">// 释放一块地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getNewArena</span><span class="params">(AddressPoolType type, <span class="type">int</span> index)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ByteMemoryManager初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ByteMemoryManager::<span class="built_in">ByteMemoryManager</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">initialize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteMemoryManager::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size = minSize;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MEM_BLOCK_TYPES; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arenas[i] = <span class="literal">nullptr</span>;</span><br><span class="line">        arenaSize[i] = size;</span><br><span class="line">        size = size &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以下是内存分配的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">ByteMemoryManager::allocate</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; MEM_BLOCK_TYPES &amp;&amp; arenaSize[index] &lt; size)</span><br><span class="line">        ++index;</span><br><span class="line"></span><br><span class="line">    PCB *pcb = programManager.running;</span><br><span class="line">    AddressPoolType poolType = (pcb-&gt;pageDirectoryAddress) ? AddressPoolType::USER : AddressPoolType::KERNEL;</span><br><span class="line">    <span class="type">void</span> *ans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == MEM_BLOCK_TYPES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 上取整</span></span><br><span class="line">        <span class="type">int</span> pageAmount = (size + <span class="built_in">sizeof</span>(Arena) + PAGE_SIZE - <span class="number">1</span>) / PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">        ans = memoryManager.<span class="built_in">allocatePages</span>(poolType, pageAmount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans)</span><br><span class="line">        &#123;</span><br><span class="line">            Arena *arena = (Arena *)ans;</span><br><span class="line">            arena-&gt;type = ArenaType::ARENA_MORE;</span><br><span class="line">            arena-&gt;counter = pageAmount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;---ByteMemoryManager::allocate----\n&quot;);</span></span><br><span class="line">        <span class="keyword">if</span> (arenas[index] == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">getNewArena</span>(poolType, index))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次取出内存块链表中的第一个内存块</span></span><br><span class="line">        ans = arenas[index];</span><br><span class="line">        arenas[index] = ((MemoryBlockListItem *)ans)-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arenas[index])</span><br><span class="line">        &#123;</span><br><span class="line">            (arenas[index])-&gt;previous = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arena *arena = (Arena *)((<span class="type">int</span>)ans &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">        --(arena-&gt;counter);</span><br><span class="line">        <span class="comment">//printf(&quot;---ByteMemoryManager::allocate----\n&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果空闲arena链表为空，则需要从内核中分配一个页，写入元信息，然后将该页划分成一个个arena。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteMemoryManager::getNewArena</span><span class="params">(AddressPoolType type, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *ptr = memoryManager.<span class="built_in">allocatePages</span>(type, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存块的数量</span></span><br><span class="line">    <span class="type">int</span> times = (PAGE_SIZE - <span class="built_in">sizeof</span>(Arena)) / arenaSize[index];</span><br><span class="line">    <span class="comment">// 内存块的起始地址</span></span><br><span class="line">    <span class="type">int</span> address = (<span class="type">int</span>)ptr + <span class="built_in">sizeof</span>(Arena);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录下内存块的数据</span></span><br><span class="line">    Arena *arena = (Arena *)ptr;</span><br><span class="line">    arena-&gt;type = (ArenaType)index;</span><br><span class="line">    arena-&gt;counter = times;</span><br><span class="line">    <span class="comment">// printf(&quot;---ByteMemoryManager::getNewArena: type: %d, arena-&gt;counter: %d\n&quot;, index, arena-&gt;counter);</span></span><br><span class="line"></span><br><span class="line">    MemoryBlockListItem *prevPtr = (MemoryBlockListItem *)address;</span><br><span class="line">    MemoryBlockListItem *curPtr = <span class="literal">nullptr</span>;</span><br><span class="line">    arenas[index] = prevPtr;</span><br><span class="line">    prevPtr-&gt;previous = <span class="literal">nullptr</span>;</span><br><span class="line">    prevPtr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    --times;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (times)</span><br><span class="line">    &#123;</span><br><span class="line">        address += arenaSize[index];</span><br><span class="line">        curPtr = (MemoryBlockListItem *)address;</span><br><span class="line">        prevPtr-&gt;next = curPtr;</span><br><span class="line">        curPtr-&gt;previous = prevPtr;</span><br><span class="line">        curPtr-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        prevPtr = curPtr;</span><br><span class="line">        --times;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来实现内存释放。</p>
<p>内存释放非常简单，当我们释放一个动态分配的内存地址时，我们可以找到这个地址所在的页。然后通过这个页开头保存的元信息就能够找到这个地址对应的arena类型。最后将这个arena放到对应的空闲arena链表即可。</p>
<p>特别地，当一个页内的所有arena都被释放时，我们需要释放这个页。</p>
<p>教程中的代码有一些拼写问题和release没有指定内存池是kernel还是user的问题，进行了修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteMemoryManager::release</span><span class="params">(<span class="type">void</span> *address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 由于Arena是按页分配的，所以其首地址的低12位必定0，</span></span><br><span class="line">    <span class="comment">// 其中划分的内存块的高20位也必定与其所在的Arena首地址相同</span></span><br><span class="line">    Arena *arena = (Arena *)((<span class="type">int</span>)address &amp; <span class="number">0xfffff000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arena-&gt;type == ARENA_MORE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> address = (<span class="type">int</span>)arena;</span><br><span class="line"></span><br><span class="line">        memeoryManager.<span class="built_in">releasePage</span>(address, arena-&gt;counter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        MemoryBlockListItem *itemPtr = (MemoryBlockListItem *)address;</span><br><span class="line">        itemPtr-&gt;next = arenas[arena-&gt;type];</span><br><span class="line">        itemPtr-&gt;previous = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (itemPtr-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            itemPtr-&gt;next-&gt;previous = itemPtr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arenas[arena-&gt;type] = itemPtr;</span><br><span class="line">        ++(arena-&gt;counter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若整个Arena被归还，则清空分配给Arena的页</span></span><br><span class="line">        <span class="type">int</span> amount = (PAGE_SIZE - <span class="built_in">sizeof</span>(Arena)) / arenaSize[arena-&gt;type];</span><br><span class="line">        <span class="comment">// printf(&quot;---ByteMemoryManager::release---: arena-&gt;counter: %d, amount: %d\n&quot;, arena-&gt;counter, amount);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arena-&gt;counter == amount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将属于Arena的内存块从链上删除</span></span><br><span class="line">            <span class="keyword">while</span> (itemPtr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">int</span>)arena != ((<span class="type">int</span>)itemPtr &amp; <span class="number">0xfffff000</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    itemPtr = itemPtr-&gt;next;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (itemPtr-&gt;previous == <span class="literal">nullptr</span>) <span class="comment">// 链表中的第一个节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    arenas[arena-&gt;type] = itemPtr-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span> (itemPtr-&gt;next)</span><br><span class="line">                    &#123;</span><br><span class="line">                        itemPtr-&gt;next-&gt;previous = <span class="literal">nullptr</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    itemPtr-&gt;previous-&gt;next = itemPtr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (itemPtr-&gt;next)</span><br><span class="line">                &#123;</span><br><span class="line">                    itemPtr-&gt;next-&gt;previous = itemPtr-&gt;previous;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                itemPtr = itemPtr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            memeoryManager.<span class="built_in">releasePage</span>((<span class="type">int</span>)address, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于进程有自己的内存空间，我们修改PCB，在PCB中加入 <code>ByteMemeoryManager</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct PCB</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    ByteMemoryManager byteMemoryManager; // 进程内存管理者</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在pcb初始化函数中加上</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread-&gt;byteMemoryManager.<span class="built_in">initialize</span>();</span><br></pre></td></tr></table></figure>

<p>setup函数中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteMemoryManager kernelByteMemoryManager;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">setup_kernel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    kernelByteMemoryManager.<span class="built_in">initialize</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3. 关键代码"></a>3. <strong>关键代码</strong></h2><p>见上一部分</p>
<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. <strong>实验结果</strong></h2><p>我们在这里加上延迟来展示没有实现互斥时发生的错误，同时把时间片轮转的ticks调低来增加并发度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">ByteMemoryManager::allocate</span><span class="params">(<span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	ans = arenas[index];</span><br><span class="line">        <span class="comment">//设置延迟</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> delay = <span class="number">0xfffffff</span>;</span><br><span class="line">        <span class="keyword">while</span>(delay--);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看这个样例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">second_thread</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first_thread get addr0(50) %x\n&quot;</span>, addr);</span><br><span class="line">    <span class="type">void</span>* addr1 = <span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first_thread get addr1(30) %x\n&quot;</span>, addr1);</span><br><span class="line">    <span class="built_in">free</span>(addr);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">free</span>(addr1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">third_thread</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* addr2 = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;second_thread get addr2(50) %x\n&quot;</span>,addr2);</span><br><span class="line">    <span class="built_in">free</span>(addr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>thread</code>1和 <code>tread2</code>都malloc了50B,在tread1获取了ans之后延迟，并没有设置 <code>arenas[index] = ((MemoryBlockListItem *)ans)-&gt;next;</code>此时tread2被调度上处理机，获取了一样的地址。</p>
<p>分配了同样的地址会导致release的时候也无法回收，所以我们只看到了两个release.</p>
<p>无锁:</p>
<p><img src="/2024/07/12/oslab9/oslab9/1720841743990.png" alt="1720841743990"></p>
<p>有锁：</p>
<p>在这里加上锁保证对arena数组的互斥访问</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">ByteMemoryManager::allocate</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt_sem.<span class="built_in">P</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---ByteMemoryManager::allocate----\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (arenas[index] == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">getNewArena</span>(poolType, index))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;getNewArena\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次取出内存块链表中的第一个内存块</span></span><br><span class="line">        ans = arenas[index];</span><br><span class="line">        <span class="comment">//设置延迟</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> delay = <span class="number">0xfffffff</span>;</span><br><span class="line">        <span class="keyword">while</span>(delay--);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        arenas[index] = ((MemoryBlockListItem *)ans)-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arenas[index])</span><br><span class="line">        &#123;</span><br><span class="line">            (arenas[index])-&gt;previous = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arena *arena = (Arena *)((<span class="type">int</span>)ans &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">        --(arena-&gt;counter);</span><br><span class="line">        <span class="comment">//printf(&quot;---ByteMemoryManager::allocate----\n&quot;);</span></span><br><span class="line">        bt_sem.<span class="built_in">V</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁之后在 <code>thread1</code>和 <code>tread2</code>都malloc了50B时分配的地址是不同的。可见实现了分配时的互斥。<code>thread1</code>在exit的时候回收了资源，所以 <code>thread2</code>malloc分配到的地址和thread1是一样的。</p>
<p><img src="/2024/07/12/oslab9/oslab9/1720841689908.png" alt="1720841689908"></p>
<p>在其他需要互斥的地方加上信号量：</p>
<p>这里加上是为了保证在为进程分配内存的时候实现的互斥以及malloc分配空间&gt;1024Byte时的分配</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryManager::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semaphore.<span class="built_in">initialize</span>(<span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MemoryManager::allocatePages</span><span class="params">(<span class="keyword">enum</span> AddressPoolType type, <span class="type">const</span> <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semaphore.<span class="built_in">P</span>();</span><br><span class="line">    <span class="comment">// 第一步：从虚拟地址池中分配若干虚拟页</span></span><br><span class="line">    <span class="type">int</span> virtualAddress = <span class="built_in">allocateVirtualPages</span>(type, count);</span><br><span class="line">    ...</span><br><span class="line">    semaphore.<span class="built_in">V</span>();</span><br><span class="line">    <span class="keyword">return</span> virtualAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>对于进程来说，也能通过系统调用实现正常分配内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span>* addr = <span class="built_in">malloc</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first_process get addr0(50) %x\n&quot;</span>, addr);</span><br><span class="line">    <span class="type">void</span>* addr1 = <span class="built_in">malloc</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;first_process get addr1(30) %x\n&quot;</span>, addr1);</span><br><span class="line">    <span class="built_in">free</span>(addr);</span><br><span class="line">    <span class="built_in">free</span>(addr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="/2024/07/12/oslab9/oslab9/1720857389774.png" alt="1720857389774"></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><p>这次实验可以说比较综合，涉及到内存管理、系统调用、线程互斥等多方面的内容，虽然说整体难度不大只需要在教程给出的代码上进行修改但是还是要完全理解还是有些难度。实验中遇到了没有在setup.cpp函数中BytememoryManagemebt.initalize()，导致调用默认构造函数size都被初始化为0的问题。后来发现并解决了。实验教程中采用了不同大小的块进行动态内存分配，减少了碎片，可以说是很精巧的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/20/oslab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/20/oslab7/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-20 09:55:50" itemprop="dateCreated datePublished" datetime="2024-05-20T09:55:50+08:00">2024-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-03 09:04:05" itemprop="dateModified" datetime="2024-06-03T09:04:05+08:00">2024-06-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!---
title:SYSU-2024操作系统lab3实验报告

date:2024-03-24 23:54:26

tags:os

comments:true

author:zyh
--->

<p>实验课程:                   操作系统</p>
<h1 id="实验名称-Lab7-内存管理"><a href="#实验名称-Lab7-内存管理" class="headerlink" title="实验名称:          Lab7 内存管理"></a><strong>实验名称:          Lab7 内存管理</strong></h1><ul>
<li>姓名:                    庄云皓</li>
<li>学号:                   22336327</li>
</ul>
<h2 id="1-实验要求"><a href="#1-实验要求" class="headerlink" title="1. 实验要求"></a>1. <strong>实验要求</strong></h2><h3 id="Assignment-1"><a href="#Assignment-1" class="headerlink" title="Assignment 1"></a>Assignment 1</h3><p>复现参考代码，实现二级分页机制，并能够在虚拟机地址空间中进行内存管理，包括内存的申请和释放等，截图并给出过程解释。</p>
<h3 id="Assignment-2"><a href="#Assignment-2" class="headerlink" title="Assignment 2"></a>Assignment 2</h3><p>参照理论课上的学习的物理内存分配算法如first-fit, best-fit等实现动态分区算法等，或者自行提出自己的算法。</p>
<h3 id="Assignment-3"><a href="#Assignment-3" class="headerlink" title="Assignment 3"></a>Assignment 3</h3><p>复现“虚拟页内存管理”一节的代码，完成如下要求。</p>
<ul>
<li>结合代码分析虚拟页内存分配的三步过程和虚拟页内存释放。</li>
<li>构造测试例子来分析虚拟页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测试。否则，结合测例简要分析虚拟页内存管理的实现的正确性。</li>
<li>（<strong>不做要求，对评分没有影响</strong>）如果你有想法，可以在自己的理解的基础上，参考ucore，《操作系统真象还原》，《一个操作系统的实现》等资料来实现自己的虚拟页内存管理。在完成之后，你需要指明相比较于本教程，你的实现的虚拟页内存管理的特点所在。</li>
</ul>
<h3 id="Assignment-4"><a href="#Assignment-4" class="headerlink" title="Assignment 4"></a>Assignment 4</h3><p>参照理论课上虚拟内存管理的页面置换算法如FIFO、LRU等，实现页面置换，也可以提出自己的算法。</p>
<h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2. 实验过程"></a>2. <strong>实验过程</strong></h2><h3 id="Assignment1"><a href="#Assignment1" class="headerlink" title="Assignment1"></a><strong>Assignment1</strong></h3><p>BitMap</p>
<p><code>setup.cpp</code>中</p>
<p><code>char*pages_0= (char*)memoryManager.allocatePhysicalPages(AddressPoolType::KERNEL, 128);</code></p>
<p>调用了 <code>MemoryManager</code>的成员函数allocatePhisicalPages</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717171735091.png" alt="1717171735091"></p>
<p>接着我们进入 <code>allocatePhysicalPages</code>,这里的resources是一个Bitmap变量，allocate在给的代码中默认采用的是first_fit的算法，<code>Bitmap::allocate</code>的功能是按照分配方式找到位图对应的位置，都置为1。位图位与内核空间中。</p>
<p>第一次调用 <code>Bitmap::allocate</code>的返回值为0，分配完128pages，后第二次调用 <code>Bitmap::allocate</code>返回值为128（返回值为分配时bitmap数组的起始位置）</p>
<p>则 <code>AddressPool::allocate</code>的返回值为PAGE_SIZE*start+startAddress 即从哪个地址开始分配 ,这里的startAddress可认为是起始地址的基址，是2097152，即0x200000。</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717172406777.png" alt="1717172406777"></p>
<p>release的过程类似:(address - startAddress&#x2F;PAGE_SIZE)算出bitmap对应的位置index,然后从该位置开始把后面count个元素置零。</p>
<h3 id="Assignment2"><a href="#Assignment2" class="headerlink" title="Assignment2"></a><strong>Assignment2</strong></h3><ul>
<li>first_fit：从低地址开始搜索,找到第一个可以容纳请求块的空闲分区</li>
<li>best_fit：从所有可用分区中找到最小的能够满足请求的分区</li>
<li>worst_fit：从所有可用分区中找到最大的能够满足请求的分区<br>具体实现见关键代码处</li>
</ul>
<h3 id="Assignment3"><a href="#Assignment3" class="headerlink" title="Assignment3"></a><strong>Assignment3</strong></h3><p>虚拟页内存分配的三步：</p>
<ul>
<li><strong>从虚拟地址池中分配连续的多个虚拟页</strong> 。<img src="/2024/05/20/oslab7/oslab7/1717297841023.png" alt="1717297841023"><br>我们建立了用户虚拟地址池,首先定义虚拟地址起始地址的宏，使得分配的页空间虚拟地址仅在3-4GB之<br>间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_VIRTUAL_START 0xc0100000</span></span><br></pre></td></tr></table></figure>

<p>  从地址池中分配count个连续页的过程在assignment1中已经提到，不再赘述。<br>这是 <code>kernel/memory.cpp</code>中的 <code>MemoryManager::allocatePages</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MemoryManager::allocatePages</span><span class="params">(<span class="keyword">enum</span> AddressPoolType type, <span class="type">const</span> <span class="type">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：从虚拟地址池中分配若干虚拟页</span></span><br><span class="line"><span class="type">int</span> virtualAddress = <span class="built_in">allocateVirtualPages</span>(type, count);</span><br><span class="line"><span class="keyword">if</span> (!virtualAddress)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们要开始为每一个虚拟页指定物理页，这件事分为两步，先分配虚拟页，再建立虚拟页和物理页的联系。分配过程和之前一样</p>
<ul>
<li><strong>从物理地址池中为每一个虚拟页分配相应大小的物理页</strong> 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="type">int</span> physicalPageAddress;</span><br><span class="line"><span class="type">int</span> vaddress = virtualAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次为每一个虚拟页指定物理页</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i, vaddress += PAGE_SIZE)</span><br><span class="line">&#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 第二步：从物理地址池中分配一个物理页</span></span><br><span class="line">    physicalPageAddress = <span class="built_in">allocatePhysicalPages</span>(type, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (physicalPageAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;allocate physical page 0x%x\n&quot;, physicalPageAddress);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第三步：为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。</span></span><br><span class="line">        flag = <span class="built_in">connectPhysicalVirtualPage</span>(vaddress, physicalPageAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配失败，释放前面已经分配的虚拟页和物理页表</span></span><br><span class="line">    <span class="keyword">if</span> (!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 前i个页表已经指定了物理页</span></span><br><span class="line">        <span class="built_in">releasePages</span>(type, virtualAddress, i);</span><br><span class="line">        <span class="comment">// 剩余的页表未指定物理页</span></span><br><span class="line">        <span class="built_in">releaseVirtualPages</span>(type, virtualAddress + i * PAGE_SIZE, count - i);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> virtualAddress;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在页目录表和页表中建立虚拟页和物理页之间的对应关系</strong> 。此时，由于分页机制的存在，物理页的地址可以不连续。CPU的MMU会在程序执行过程中将虚拟地址翻译成物理地址。</li>
</ul>
<p>我们具体来看这个函数：<code>connectPhysicalVirtualPage(vaddress, physicalPageAddress);</code></p>
<p><img src="/2024/05/20/oslab7/oslab7/1717315484763.png" alt="1717315484763"></p>
<ul>
<li>首先得到虚拟地址对应的页目录项pde和页表项pte</li>
<li>如果页目录项无页表则1.分配物理页给页表   2.使页目录项指向页表   3.进行空间的分配</li>
<li>有的话直接将页表项指向物理页</li>
</ul>
<p>一些关键代码的解释:<br><code>*pde &amp; 0x00000001</code>表示获取存在位（P位），若为0则取分配物理页</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717316547661.png" alt="1717316547661"></p>
<p>将页表项指向物理页，<code>*physicalPageAddress | 0x7</code>中的按位或运算是为了设置页目录项的标志位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MemoryManager::connectPhysicalVirtualPage</span><span class="params">(<span class="type">const</span> <span class="type">int</span> virtualAddress, <span class="type">const</span> <span class="type">int</span> physicalPageAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计算虚拟地址对应的页目录项和页表项</span></span><br><span class="line">    <span class="type">int</span> *pde = (<span class="type">int</span> *)<span class="built_in">toPDE</span>(virtualAddress);</span><br><span class="line">    <span class="type">int</span> *pte = (<span class="type">int</span> *)<span class="built_in">toPTE</span>(virtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 页目录项无对应的页表，先分配一个页表</span></span><br><span class="line">    <span class="keyword">if</span>(!(*pde &amp; <span class="number">0x00000001</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从内核物理地址空间中分配一个页表</span></span><br><span class="line">        <span class="type">int</span> page = <span class="built_in">allocatePhysicalPages</span>(AddressPoolType::KERNEL, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使页目录项指向页表</span></span><br><span class="line">        *pde = page | <span class="number">0x7</span>;</span><br><span class="line">        <span class="comment">// 初始化页表</span></span><br><span class="line">        <span class="type">char</span> *pagePtr = (<span class="type">char</span> *)(((<span class="type">int</span>)pte) &amp; <span class="number">0xfffff000</span>);</span><br><span class="line">        <span class="built_in">memset</span>(pagePtr, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使页表项指向物理页</span></span><br><span class="line">    *pte = physicalPageAddress | <span class="number">0x7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放内存过程：分为两步,首先释放物理页再释放虚拟页。</p>
<p>要注意把页表项pte置空，防止再次被访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryManager::releasePages</span><span class="params">(<span class="keyword">enum</span> AddressPoolType type, <span class="type">const</span> <span class="type">int</span> virtualAddress, <span class="type">const</span> <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> vaddr = virtualAddress;</span><br><span class="line">    <span class="type">int</span> *pte;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i, vaddr += PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 第一步，对每一个虚拟页，释放为其分配的物理页</span></span><br><span class="line">        <span class="built_in">releasePhysicalPages</span>(type, <span class="built_in">vaddr2paddr</span>(vaddr), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置页表项为不存在，防止释放后被再次使用</span></span><br><span class="line">        pte = (<span class="type">int</span> *)<span class="built_in">toPTE</span>(vaddr);</span><br><span class="line">        *pte = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，释放虚拟页</span></span><br><span class="line">    <span class="built_in">releaseVirtualPages</span>(type, virtualAddress, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过打印测试用例发现，确实达到了虚拟内存连续分配，物理内存分配不连续的效果</p>
<p>测试用例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p1 = (<span class="type">char</span> *)memoryManager.<span class="built_in">allocatePages</span>(AddressPoolType::KERNEL, <span class="number">100</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = (<span class="type">char</span> *)memoryManager.<span class="built_in">allocatePages</span>(AddressPoolType::KERNEL, <span class="number">10</span>);</span><br><span class="line">    <span class="type">char</span> *p3 = (<span class="type">char</span> *)memoryManager.<span class="built_in">allocatePages</span>(AddressPoolType::KERNEL, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x %x %x\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">    memoryManager.<span class="built_in">releasePages</span>(AddressPoolType::KERNEL, (<span class="type">int</span>)p2, <span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="type">char</span> *)memoryManager.<span class="built_in">allocatePages</span>(AddressPoolType::KERNEL, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">    p2 = (<span class="type">char</span> *)memoryManager.<span class="built_in">allocatePages</span>(AddressPoolType::KERNEL, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, p2);</span><br></pre></td></tr></table></figure>

<p>虚拟内存分配结果:p2释放后重新分配100页的空间时，从0xc01d2000,而分配10页空间时从原来释放内存的0x164000开始</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717372803677.png" alt="1717372803677"></p>
<p>物理内存则在分配100页时从原来释放的地址的开始，如果孔空间不够继续找到下一个空的空间。</p>
<p>一些bug:</p>
<p>没有使用互斥机制导致不同线程可能都进入临界区，分配到相同的物理地址。我们延长了等待时间使得这个错误发生。具体错误见实验结果处。</p>
<p>解决方案：使用信号量解决.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemoryManager::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semaphore.<span class="built_in">initialize</span>(<span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MemoryManager::allocatePages</span><span class="params">(<span class="keyword">enum</span> AddressPoolType type, <span class="type">const</span> <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semaphore.<span class="built_in">P</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 第一步：从虚拟地址池中分配若干虚拟页</span></span><br><span class="line">    <span class="type">int</span> virtualAddress = <span class="built_in">allocateVirtualPages</span>(type, count);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!virtualAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="type">int</span> physicalPageAddress;</span><br><span class="line">    <span class="type">int</span> vaddress = virtualAddress;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 依次为每一个虚拟页指定物理页</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i, vaddress += PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 第二步：从物理地址池中分配一个物理页</span></span><br><span class="line">        physicalPageAddress = <span class="built_in">allocatePhysicalPages</span>(type, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (physicalPageAddress)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//printf(&quot;allocate physical page 0x%x\n&quot;, physicalPageAddress);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第三步：为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。</span></span><br><span class="line">            flag = <span class="built_in">connectPhysicalVirtualPage</span>(vaddress, physicalPageAddress);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    semaphore.<span class="built_in">V</span>();</span><br><span class="line">        <span class="comment">// 分配失败，释放前面已经分配的虚拟页和物理页表</span></span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前i个页表已经指定了物理页</span></span><br><span class="line">            <span class="built_in">releasePages</span>(type, virtualAddress, i);</span><br><span class="line">            <span class="comment">// 剩余的页表未指定物理页</span></span><br><span class="line">            <span class="built_in">releaseVirtualPages</span>(type, virtualAddress + i * PAGE_SIZE, count - i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> virtualAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有可能在其他地方也会出现没有互斥访问导致的问题没有解决。</p>
<h3 id="Assignment-4-1"><a href="#Assignment-4-1" class="headerlink" title="Assignment 4"></a><strong>Assignment 4</strong></h3><p>本实验中我在win环境中模拟LRU</p>
<p><strong>LRU页面置换</strong></p>
<p>核心原理是基于“最近使用的数据将来被使用的概率更高”这一假设，即如果一个数据最近被访问过，那么它在不久的将来很可能再次被访问；相反，如果一个数据很长时间没有被访问，那么它在将来被访问的概率较低。我们使用一个times变量来记录多少次没有被访问过，取最大的淘汰。</p>
<p>实现代码见关键代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">memory</span>&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> times;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num; <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 缓存空间</span></span><br><span class="line">    memory mem[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;capacity;i++)&#123;</span><br><span class="line">        	mem[i].id = <span class="number">-1</span>;</span><br><span class="line">        	mem[i].times = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">tihuan</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> max_id = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mem[i].times&gt;max)&#123;</span><br><span class="line">				max = mem[i].times;</span><br><span class="line">				max_id = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d被替换为%d\n&quot;</span>,mem[max_id].id,k);</span><br><span class="line">		mem[max_id].id= k;</span><br><span class="line">		mem[max_id].times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mem[i].id== n)&#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				mem[i].times = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">    		mem[i].times++;</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="keyword">if</span>(!<span class="built_in">find</span>(k))&#123;</span><br><span class="line">    		<span class="keyword">if</span>(num&lt;capacity)&#123;</span><br><span class="line">    			mem[num].id=k;</span><br><span class="line">    			mem[num].times=<span class="number">0</span>;</span><br><span class="line">    			num++;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">tihuan</span>(k);</span><br><span class="line">			&#125;</span><br><span class="line">    	</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;id %d hit\n&quot;</span>,k);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;page id now:\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,mem[i].id);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> seq[<span class="number">10</span>]= &#123;<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">LRUCache <span class="title">cache1</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 设置缓存容量为3</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		cache1.<span class="built_in">put</span>(seq[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3. 关键代码"></a>3. <strong>关键代码</strong></h2><p> Assignment1中分配内存用的是和Assignment2一样的测试代码</p>
<p>Assignment2中first_fit:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BitMap::allocate</span><span class="params">(<span class="type">const</span> <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index, empty, start;</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 越过已经分配的资源</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; <span class="built_in">get</span>(index))</span><br><span class="line">            ++index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在连续的count个资源</span></span><br><span class="line">        <span class="keyword">if</span> (index == length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到1个未分配的资源</span></span><br><span class="line">        <span class="comment">// 检查是否存在从index开始的连续count个资源</span></span><br><span class="line">        empty = <span class="number">0</span>;</span><br><span class="line">        start = index;</span><br><span class="line">        <span class="keyword">while</span> ((index &lt; length) &amp;&amp; (!<span class="built_in">get</span>(index)) &amp;&amp; (empty &lt; count))</span><br><span class="line">        &#123;</span><br><span class="line">            ++empty;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存在连续的count个资源</span></span><br><span class="line">        <span class="keyword">if</span> (empty == count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>(start + i, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>best_fit:使用min_space和min_start记录当前最小且大于count的最小空间，和其对应的起始地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BitMap::best_fit</span><span class="params">(<span class="type">const</span> <span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index, empty, start;</span><br><span class="line">    <span class="type">int</span> min_space = <span class="number">0xffffff</span>;</span><br><span class="line">    <span class="type">int</span> min_start = <span class="number">0</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 越过已经分配的资源</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; <span class="built_in">get</span>(index))&#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不存在连续的count个资源</span></span><br><span class="line">        <span class="keyword">if</span> (index == length)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到1个未分配的资源</span></span><br><span class="line">        <span class="comment">// 检查是否存在从index开始的连续count个资源</span></span><br><span class="line">        empty = <span class="number">0</span>;</span><br><span class="line">        start = index;</span><br><span class="line">        <span class="keyword">while</span> ((index &lt; length) &amp;&amp; (!<span class="built_in">get</span>(index)))</span><br><span class="line">        &#123;</span><br><span class="line">            ++empty;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(empty&gt;=count &amp;&amp; empty&lt;min_space)&#123;</span><br><span class="line">            min_space = empty;</span><br><span class="line">            min_start = start;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 存在连续的count个资源</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(min_space == <span class="number">0xffffff</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    start = min_start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>(start + i, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worst_fit:则与best_fit相反</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BitMap::worst_fit</span><span class="params">(<span class="type">const</span> <span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index, empty, start;</span><br><span class="line">    <span class="type">int</span> max_space = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> max_start = <span class="number">0</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 越过已经分配的资源</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; length &amp;&amp; <span class="built_in">get</span>(index))&#123;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 不存在连续的count个资源</span></span><br><span class="line">        <span class="keyword">if</span> (index == length)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到1个未分配的资源</span></span><br><span class="line">        <span class="comment">// 检查是否存在从index开始的连续count个资源</span></span><br><span class="line">        empty = <span class="number">0</span>;</span><br><span class="line">        start = index;</span><br><span class="line">        <span class="keyword">while</span> ((index &lt; length) &amp;&amp; (!<span class="built_in">get</span>(index)))</span><br><span class="line">        &#123;</span><br><span class="line">            ++empty;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(empty&gt;=count &amp;&amp; empty&gt;max_space)&#123;</span><br><span class="line">            max_space = empty;</span><br><span class="line">            max_start = start;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 存在连续的count个资源</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max_space == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    start = max_start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>(start + i, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Assignment4</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">memory</span>&#123;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="type">int</span> times;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num; <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">// 缓存空间</span></span><br><span class="line">    memory mem[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;capacity;i++)&#123;</span><br><span class="line">        	mem[i].id = <span class="number">-1</span>;</span><br><span class="line">        	mem[i].times = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">tihuan</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> max_id = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mem[i].times&gt;max)&#123;</span><br><span class="line">				max = mem[i].times;</span><br><span class="line">				max_id = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d被替换为%d\n&quot;</span>,mem[max_id].id,k);</span><br><span class="line">		mem[max_id].id= k;</span><br><span class="line">		mem[max_id].times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mem[i].id== n)&#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				mem[i].times = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">    		mem[i].times++;</span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="keyword">if</span>(!<span class="built_in">find</span>(k))&#123;</span><br><span class="line">    		<span class="keyword">if</span>(num&lt;capacity)&#123;</span><br><span class="line">    			mem[num].id=k;</span><br><span class="line">    			mem[num].times=<span class="number">0</span>;</span><br><span class="line">    			num++;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">tihuan</span>(k);</span><br><span class="line">			&#125;</span><br><span class="line">  </span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;id %d hit\n&quot;</span>,k);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;page id now:\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,mem[i].id);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> seq[<span class="number">10</span>]= &#123;<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">LRUCache <span class="title">cache1</span><span class="params">(<span class="number">3</span>)</span></span>; <span class="comment">// 设置缓存容量为3</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">		cache1.<span class="built_in">put</span>(seq[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. <strong>实验结果</strong></h2><h2 id="Assignment-2-1"><a href="#Assignment-2-1" class="headerlink" title="Assignment 2"></a>Assignment 2</h2><p>分配四次，释放两次内存后的内存空间如左图所示，右侧是采用不同方法继续分配两次空间后的结果</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717131430906.png" alt="1717131430906"></p>
<p><img src="/2024/05/20/oslab7/oslab7/1717116874977.png" alt="1717116874977"></p>
<p>best_fit:</p>
<p>可以看到，</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717086633066.png" alt="1717086633066"></p>
<p>worst_fit</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717130935790.png" alt="1717130935790"></p>
<h3 id="Assignment-3-1"><a href="#Assignment-3-1" class="headerlink" title="Assignment 3"></a>Assignment 3</h3><p>没有实现互斥机制时的错误：分配到了同样的虚拟地址</p>
<p>测试用例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">memoryManager memoryManager;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">second_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p2 = (<span class="type">char</span> *)memoryManager.<span class="built_in">allocatePages</span>(AddressPoolType::KERNEL, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread2 %x\n&quot;</span>,p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">third_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p3 = (<span class="type">char</span> *)memoryManager.<span class="built_in">allocatePages</span>(AddressPoolType::KERNEL, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread3 %x\n&quot;</span>,p3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">first_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid1 = programManager.<span class="built_in">executeThread</span>(second_thread, <span class="literal">nullptr</span>, <span class="string">&quot;second thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> pid2 = programManager.<span class="built_in">executeThread</span>(third_thread, <span class="literal">nullptr</span>, <span class="string">&quot;third thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 第1个线程不可以返回</span></span><br><span class="line">    <span class="comment">// stdio.moveCursor(0);</span></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; 25 * 80; ++i)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     stdio.print(&#x27; &#x27;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// stdio.moveCursor(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1 = (<span class="type">char</span> *)memoryManager.<span class="built_in">allocatePages</span>(AddressPoolType::KERNEL, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread1 %x\n&quot;</span>,p1);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/20/oslab7/oslab7/1717376584481.png" alt="1717376584481"></p>
<p>改正后的结果：</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717348305387.png" alt="1717348305387"></p>
<h3 id="Assignment-4-2"><a href="#Assignment-4-2" class="headerlink" title="Assignment 4"></a>Assignment 4</h3><p>LRU算法，引用串为7,0,1,2,0,3,0,4,2,3，可用帧为3时的结果</p>
<p><img src="/2024/05/20/oslab7/oslab7/1717347573550.png" alt="1717347573550"></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><p>   通过这次实验，我更加深刻认识到内存管理的重要意义，了解了二级页表的实现机制。了解了位图，内存池等相关概念和实现。了解了虚拟内存管理机制，页内存的分配和释放过程，最后实现用FIFO算法实现了页面置换。用LRU算法在win环境下模拟了页面置换的过程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/06/oslab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/06/oslab6/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-06 11:08:57" itemprop="dateCreated datePublished" datetime="2024-05-06T11:08:57+08:00">2024-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-27 01:01:58" itemprop="dateModified" datetime="2024-05-27T01:01:58+08:00">2024-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!---
title:SYSU-2024操作系统lab3实验报告

date:2024-03-24 23:54:26

tags:os

comments:true

author:zyh
--->

<h1 id="实验名称-Lab6-并发与锁机制"><a href="#实验名称-Lab6-并发与锁机制" class="headerlink" title="实验名称:          Lab6 并发与锁机制"></a><strong>实验名称:          Lab6 并发与锁机制</strong></h1><p>学生姓名:                    庄云皓</p>
<p>学生学号:                   22336327</p>
<h2 id="1-实验要求"><a href="#1-实验要求" class="headerlink" title="1. 实验要求"></a>1. <strong>实验要求</strong></h2><h2 id="Assignment-1-代码复现题"><a href="#Assignment-1-代码复现题" class="headerlink" title="Assignment 1 代码复现题"></a><strong>Assignment 1 代码复现题</strong></h2><h3 id="1-1-代码复现"><a href="#1-1-代码复现" class="headerlink" title="1.1 代码复现"></a>1.1 代码复现</h3><p>在本章中，我们已经实现了自旋锁和信号量机制。现在，同学们需要复现教程中的自旋锁和信号量的实现方法，分别使用二者解决一个同步互斥问题，如消失的芝士汉堡问题。最后，将结果截图并说说你是怎么做的。</p>
<h3 id="1-2-锁机制的实现"><a href="#1-2-锁机制的实现" class="headerlink" title="1.2 锁机制的实现"></a>1.2 锁机制的实现</h3><p>我们使用了原子指令 <code>xchg</code>来实现自旋锁。但是，这种方法并不是唯一的。例如，x86指令中提供了另外一个原子指令 <code>bts</code>和 <code>lock</code>前缀等，这些指令也可以用来实现锁机制。现在，同学们需要结合自己所学的知识，实现一个与本教程的实现方式不完全相同的锁机制。最后，测试你实现的锁机制，将结果截图并说说你是怎么做的。</p>
<p>提示：在 <code>asm_utils.asm</code>中实现你自己的原子操作 <code>your_asm_atomic_exchange</code>，并在 <code>sync.cpp</code>中做相应修改。</p>
<h2 id="Assignment-2-生产者-消费者问题"><a href="#Assignment-2-生产者-消费者问题" class="headerlink" title="Assignment 2 生产者-消费者问题"></a><strong>Assignment 2 生产者-消费者问题</strong></h2><h3 id="2-1-Race-Condition"><a href="#2-1-Race-Condition" class="headerlink" title="2.1 Race Condition"></a>2.1 Race Condition</h3><p>同学们可以任取一个生产者-消费者问题，然后在lab6的代码环境下创建多个线程来模拟这个问题。在2.1中，我们不使用任何同步互斥的工具。因此，这些线程可能会产生冲突，进而无法产生我们预期的结果。同学们需要将这个产生错误的场景呈现出来，将结果截图并说说你是怎么做的。</p>
<h3 id="2-2-信号量解决方法"><a href="#2-2-信号量解决方法" class="headerlink" title="2.2 信号量解决方法"></a>2.2 信号量解决方法</h3><p>使用信号量解决上述你模拟的生产者-消费者问题。将结果截图并说说你是怎么做的。</p>
<p>提示：</p>
<p>①经典的生产者-消费者问题有读者-写者问题、有界缓冲区问题等，可任取一个来模拟。</p>
<p>②模拟生产者-消费者问题的步骤：1、在代码中创建多个线程，分别代表生产者和消费者。2、编写生产者和消费者的线程函数。在这些函数中，根据问题的具体场景实现生产数据和消费数据的逻辑。3、创建并启动生产者和消费者线程。观察线程之间的交互并记录结果。4、展示没有使用同步互斥工具（如信号量）时，线程之间可能产生的冲突。5、使用信号量解决同步问题，并展示解决后的结果。</p>
<p>③样例视频模拟了读者-写者问题的场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟读错误</span></span><br><span class="line"><span class="comment">//创建线程读第1-4条记录</span></span><br><span class="line">programManager.<span class="built_in">executeThread</span>(readFirstQuote, <span class="literal">nullptr</span>, <span class="string">&quot;second thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line">programManager.<span class="built_in">executeThread</span>(readSecondQuote, <span class="literal">nullptr</span>, <span class="string">&quot;third thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line">programManager.<span class="built_in">executeThread</span>(readThirdQuote, <span class="literal">nullptr</span>, <span class="string">&quot;fourth thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line">programManager.<span class="built_in">executeThread</span>(readFourthQuote, <span class="literal">nullptr</span>, <span class="string">&quot;fifth thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//创建线程，修改第2条和第4条记录为较长内容</span></span><br><span class="line"><span class="comment">//由于写时间较长，写线程运行时间大于RRschedule的time quantum</span></span><br><span class="line">programManager.<span class="built_in">executeThread</span>(writeSecondQuote, <span class="literal">nullptr</span>, <span class="string">&quot;sixth thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line">programManager.<span class="built_in">executeThread</span>(writeFourthQuote, <span class="literal">nullptr</span>, <span class="string">&quot;seventh thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//创建线程读第2条和第4条记录</span></span><br><span class="line"><span class="comment">//发现没有读到修改后的项，而是输出了初始项</span></span><br><span class="line">programManager.<span class="built_in">executeThread</span>(readSecondQuote, <span class="literal">nullptr</span>, <span class="string">&quot;eighth thread&quot;</span>, <span class="number">1</span>);</span><br><span class="line">programManager.<span class="built_in">executeThread</span>(readFourthQuote, <span class="literal">nullptr</span>, <span class="string">&quot;ninth thread&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>而使用信号量后，可以读到修改后的项。</p>
<h2 id="Assignment-3-哲学家就餐问题"><a href="#Assignment-3-哲学家就餐问题" class="headerlink" title="Assignment 3 哲学家就餐问题"></a><strong>Assignment 3 哲学家就餐问题</strong></h2><p>假设有 5 个哲学家，他们的生活只是思考和吃饭。这些哲学家共用一个圆桌，每位都有一把椅子。在桌子中央有一碗米饭，在桌子上放着 5 根筷子。</p>
<p><img src="https://gitee.com/qin_chu_yan/sysu-2024-spring-operating-system/raw/main/lab6/gallery/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98.jpeg" alt="哲学家就餐问题"></p>
<p>当一位哲学家思考时，他与其他同事不交流。时而，他会感到饥饿，并试图拿起与他相近的两根筷子（筷子在他和他的左或右邻居之间）。一个哲学家一次只能拿起一根筷子。显然，他不能从其他哲学家手里拿走筷子。当一个饥饿的哲学家同时拥有两根筷子时，他就能吃。在吃完后，他会放下两根筷子，并开始思考。</p>
<h3 id="3-1-初步解决方法"><a href="#3-1-初步解决方法" class="headerlink" title="3.1 初步解决方法"></a>3.1 初步解决方法</h3><p>同学们需要在本教程的代码环境下，创建多个线程来模拟哲学家就餐的场景。然后，同学们需要结合信号量来实现理论课教材中给出的关于哲学家就餐问题的方法。最后，将结果截图并说说你是怎么做的。</p>
<p>该方案可能导致死锁，请举例出现死锁的场景和原因，并提出一种解决死锁的方案。</p>
<h3 id="3-2-死锁解决方法（选做）"><a href="#3-2-死锁解决方法（选做）" class="headerlink" title="3.2 死锁解决方法（选做）"></a>3.2 死锁解决方法（选做）</h3><p>虽然3.1的解决方案保证两个邻居不能同时进食，但是它可能导致死锁。现在，同学们需要想办法将死锁的场景演示出来。提出一种解决死锁的方法并实现。最后，将结果截图并说说你是怎么做的。</p>
<p>说明：</p>
<p>①为演示死锁场景，可以在哲学家进食的线程中添加等待时间，使哲学家们的操作更接近于同时进行。</p>
<p>②样例视频演示了等待时间较少——正常、等待时间较长——出现死锁。</p>
<h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2. 实验过程"></a>2. <strong>实验过程</strong></h2><h3 id="Assignment1"><a href="#Assignment1" class="headerlink" title="Assignment1"></a><strong>Assignment1</strong></h3><h4 id="1-1-1自旋锁实现方法"><a href="#1-1-1自旋锁实现方法" class="headerlink" title="1.1.1自旋锁实现方法"></a>1.1.1自旋锁实现方法</h4><p>spinlock中private变量是两个线程有公用的变量bolt,初始化为0</p>
<ul>
<li>局部变量key初始化为1</li>
<li>当第一个线程请求进入临界区时，将bolt和key交换，bolt为1，key为0，跳出循环进入临界区。</li>
<li>此时其他线程如果想要进入临界区，它的key初始化为1，bolt为1，交换后key仍然为1，循环等待（自旋）</li>
</ul>
<p>交换的过程见关键代码部分。</p>
<p>观察是否解决了消失的芝士汉堡问题</p>
<h4 id="1-1-1信号量实现方法"><a href="#1-1-1信号量实现方法" class="headerlink" title="1.1.1信号量实现方法"></a>1.1.1信号量实现方法</h4><p>在include&#x2F;sync.h下定义信号量Semaphore类。类中变量couter.表示已有资源数</p>
<ul>
<li>P():只要counter&gt;0则把counter-&#x3D;1;如果county已经&#x3D;0则把当前线程放进等待队列，将线程状态置为blockecd</li>
<li>V():counter++,获取等待队列队首元素并唤醒。</li>
</ul>
<p>在在first_thread里将semaphore 初始化为1，然后在调用 <code>mother</code>函数在<strong>mycheese_burger+&#x3D;10</strong> 前P,在print汉堡剩余量之后V防止在这段时间内汉堡被偷吃。</p>
<h4 id="1-2-锁机制的实现-1"><a href="#1-2-锁机制的实现-1" class="headerlink" title="1.2 锁机制的实现"></a>1.2 锁机制的实现</h4><p>bts指令(bit test and set)作用就是设置内容中的一个位为1, 会首先判断该位是否已经为1，是就返回1，不是则置为1,然后返回0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">my_spinlock_lock:</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    pushad</span><br><span class="line">.loop:</span><br><span class="line">    mov ebx, [ebp + 4 * 2]</span><br><span class="line">    mov edx, 0</span><br><span class="line">    lock bts dword [ebx], edx;test and set 第零位；若为0则将其置1，并将原来的值保存进CF,</span><br><span class="line">    ;第零位若为1则 CF = 1</span><br><span class="line"></span><br><span class="line">    jc .loop ;CF为1则跳转</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>观察这段上锁的函数，我们 <code>.loop</code>循环中，<code>[ebx]</code>的值是传进函数的参数，即 <code>bolt</code>变量。<code>bts</code>语句的作用是首先判断 <code>bolt</code>是否为0，如果是的话就将其改为1，将CF寄存器置0，如果是1则bolt不变，CF &#x3D; 1</p>
<p>这段代码能实现互斥访问的原因是：初始化bolt为0，如果一个进程在进入临界区时会将bolt改为1，如果此时被另一个进程抢占的话，bolt就仍然为1，循环等待。直到原进程调用 <code>unlock</code>函数将bolt置为0，另一个进程才能跳出.loop循环，进入临界区域。bts指令保证了操作的原子性。</p>
<h3 id="Assignment2"><a href="#Assignment2" class="headerlink" title="Assignment2"></a><strong>Assignment2</strong></h3><h4 id="Assignment-2-1"><a href="#Assignment-2-1" class="headerlink" title="Assignment 2.1"></a>Assignment 2.1</h4><p>一个错误场景：</p>
<p>观察下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; MAX_BUFFER_SIZE)&#123;</span><br><span class="line">            <span class="type">int</span> delay = <span class="number">0xffffff</span>;</span><br><span class="line">            <span class="keyword">while</span>(delay)&#123;</span><br><span class="line">                delay--;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[cnt] = <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;produced an item, cnt = %d\n&quot;</span>,cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; MAX_BUFFER_SIZE)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;overflow\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有实现PV操作时的错误场景：</p>
<p>可以看到当前buffer数组中的元素已经有MAX_SIZE-1个时，一个线程判断if(cnt&lt;MAX_SIZE)符合条件进入，在cnt++之前被调度下处理器。</p>
<p>另外一个线程调度上处理器，同样满足if(cnt&lt;MAX_SIZE)的条件，进入临界区域，cnt++。</p>
<p>之前被调度下来的进程重新进入running状态时cnt也++,导致cnt&gt;MAX_SIZE,出现溢出。</p>
<p>underflow的情况以此类推。</p>
<h4 id="Assignment-2-2"><a href="#Assignment-2-2" class="headerlink" title="Assignment 2.2"></a>Assignment 2.2</h4><p>信号量解决方案：</p>
<p>三个信号量</p>
<ul>
<li><code>empty_slots</code>：初始化值为MAX_SIZE</li>
<li><code>full_slots</code>: 初始化值为0</li>
<li><code>mutex</code>:初始化值为1</li>
</ul>
<p>每次进入临界区之前，<code>empty_slots.P()</code>使empty_slots.counter–， mutex.P()保证互斥访问。如果不加 <code>mutex.P()</code>的话，可能出现的情况是：MAX_SIZE大于等于2时，那么就可能有多个线程进入product的核心代码段，产生常见的资源共享问题。</p>
<p>从临界区出来时，要把full_slots++，mutex解锁。</p>
<p>这里要注意的是：<code>empty_slots.P()</code>和 <code>mutex.P()</code>不能交换顺序，这是因为，如果交换顺序，buffer为满时会死锁，因为当一个线程进入了临界区，mutex上锁，empty_slots-&gt;counter&#x3D;MAX_SIZE-1,循环等待，此时切换到另一个线程，因为已经上锁的缘故无法进行生产的.</p>
<p>同理 <code>full_slots.P()</code>和 <code>mutex.P()</code>也不能交换顺序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">empty_slots.<span class="built_in">P</span>();</span><br><span class="line">mutex.<span class="built_in">P</span>();</span><br><span class="line">buffer[cnt] = <span class="number">1</span>;</span><br><span class="line">cnt++;</span><br><span class="line">mutex.<span class="built_in">V</span>();</span><br><span class="line">full_slots.<span class="built_in">V</span>();</span><br></pre></td></tr></table></figure>

<h3 id="Assignment-3"><a href="#Assignment-3" class="headerlink" title="Assignment 3"></a><strong>Assignment 3</strong></h3><p>3.1</p>
<p>五个线程模拟五个哲学家，设置容量为5的信号量数组模拟筷子。对哲学家按顺序从 <code>0～4</code>编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为 <code>(i+l)%5</code>。</p>
<p>算法存在以下问题：当五个哲学家都想要进餐，分别拿起他们左边筷子的时候（都恰好执行完 <code>chopstick[i].wait();</code>)筷子已经被拿光了，等到他们再想拿右边的筷子的时候（执行 <code>wait(chopstick[(i+l)%5].wait()</code>)就全被阻塞了，这就出现了死锁。</p>
<p>3.2</p>
<ul>
<li>solution1</li>
</ul>
<p>一共有五个哲学家，只允许四位哲学家同时处于拿起筷子的状态，这样就不会出现有五个哲学家全都拿起左边的筷子导致死锁或者都拿起右边的筷子的情形。</p>
<p>需要设置一个信号量num,初始化为4，在拿起筷子前num.P(),放下筷子之后num.V()</p>
<ul>
<li>solution2</li>
</ul>
<p>解决这个问题有个办法是在拿起筷子前先判断左右两个筷子是否可用，可用才能拿，而且是同时拿，这样不相邻的哲学家就可以吃上饭，不会造成死锁。</p>
<p>实现这个思路又有两种具体的策略</p>
<ul>
<li><ul>
<li>i 条件 <code>(chopsticks[lhs].getcounter() &amp;&amp;chopsticks[rhs].getcounter())</code>成立才把左边和右边的筷子进行P操作。</li>
<li>ii采用另一个信号量 <code>mutex</code>进行控制，保证拿起左右手的筷子这一操作变为原子的，不能多个线程同时进行拿起左右手筷子的操作</li>
</ul>
</li>
</ul>
<h2 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3. 关键代码"></a>3. <strong>关键代码</strong></h2><h3 id="Assignment-1"><a href="#Assignment-1" class="headerlink" title="Assignment 1"></a><strong>Assignment 1</strong></h3><p>1.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; void asm_atomic_exchange(uint32 *register, uint32 *memeory);</span><br><span class="line">asm_atomic_exchange:</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    mov ebx, [ebp + 4 * 2] ; register</span><br><span class="line">    mov eax, [ebx]      ; 取出register指向的变量的值</span><br><span class="line">    mov ebx, [ebp + 4 * 3] ; memory</span><br><span class="line">    xchg [ebx], eax      ; 原子交换指令</span><br><span class="line">    mov ebx, [ebp + 4 * 2] ; memory</span><br><span class="line">    mov [ebx], eax      ; 将memory指向的值赋值给register指向的变量</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>信号量解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cheese_burger;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a_mother</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semaphore.<span class="built_in">P</span>();</span><br><span class="line">    <span class="type">int</span> delay = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mother: start to make cheese burger, there are %d cheese burger now\n&quot;</span>, cheese_burger);</span><br><span class="line">    <span class="comment">// make 10 cheese_burger</span></span><br><span class="line">    cheese_burger += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mother: oh, I have to hang clothes out.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// hanging clothes out</span></span><br><span class="line">    delay = <span class="number">0xfffffff</span>;</span><br><span class="line">    <span class="keyword">while</span> (delay)</span><br><span class="line">        --delay;</span><br><span class="line">    <span class="comment">// done</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mother: Oh, Jesus! There are %d cheese burgers\n&quot;</span>, cheese_burger);</span><br><span class="line">    semaphore.<span class="built_in">V</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a_naughty_boy</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semaphore.<span class="built_in">P</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;boy   : Look what I found!\n&quot;</span>);</span><br><span class="line">    <span class="comment">// eat all cheese_burgers out secretly</span></span><br><span class="line">    cheese_burger -= <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// run away as fast as possible</span></span><br><span class="line">    semaphore.<span class="built_in">V</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">my_spinlock_lock:</span><br><span class="line">    push ebp</span><br><span class="line">    mov ebp, esp</span><br><span class="line">    pushad</span><br><span class="line">.loop:</span><br><span class="line">    mov ebx, [ebp + 4 * 2]</span><br><span class="line">    mov eax, 1</span><br><span class="line">    mov edx, 0</span><br><span class="line">    lock bts dword [ebx], edx;test and set 第零位；若为0则将其置1，并将原来的值保存进CF,</span><br><span class="line">    ;第零位若为1则 CF = 1</span><br><span class="line"></span><br><span class="line">    jc .loop ;CF为1则跳转</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    pop ebp</span><br><span class="line">    ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Assignment2-1"><a href="#Assignment2-1" class="headerlink" title="Assignment2"></a><strong>Assignment2</strong></h3><p>2.1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_BUFFER_SIZE 1</span></span><br><span class="line"><span class="type">int</span> buffer[MAX_BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; MAX_BUFFER_SIZE)&#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> delay = <span class="number">0xffffff</span>;</span><br><span class="line">            <span class="keyword">while</span>(delay)&#123;</span><br><span class="line">                delay--;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[cnt] = <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;produced an item, cnt = %d\n&quot;</span>,cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; MAX_BUFFER_SIZE)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;overflow\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> delay = <span class="number">0xffffff</span>;</span><br><span class="line">            <span class="keyword">while</span>(delay)&#123;</span><br><span class="line">                delay--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consumerd an item, cnt = %d\n&quot;</span>,cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;underflow\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[cnt] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_BUFFER_SIZE 1</span></span><br><span class="line"><span class="type">int</span> buffer[MAX_BUFFER_SIZE];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//if(cnt &lt; MAX_BUFFER_SIZE)&#123;</span></span><br><span class="line">            <span class="type">int</span> delay = <span class="number">0xffffff</span>;</span><br><span class="line">            <span class="keyword">while</span>(delay)&#123;</span><br><span class="line">                delay--;</span><br><span class="line">            &#125;</span><br><span class="line">            empty_slots.<span class="built_in">P</span>();</span><br><span class="line">            mutex.<span class="built_in">P</span>();</span><br><span class="line">            buffer[cnt] = <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            mutex.<span class="built_in">V</span>();</span><br><span class="line">            full_slots.<span class="built_in">V</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;produced an item, cnt = %d\n&quot;</span>,cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; MAX_BUFFER_SIZE)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;overflow\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//if(cnt &gt; 0)&#123;</span></span><br><span class="line">            full_slots.<span class="built_in">P</span>();<span class="comment">// 等待缓冲区有空闲位置， 在使用PV操作时，条件变量需要在互斥锁之前</span></span><br><span class="line">            mutex.<span class="built_in">P</span>(); <span class="comment">// 保证在product时不会有其他线程访问缓冲区</span></span><br><span class="line">            <span class="type">int</span> delay = <span class="number">0xffffff</span>;</span><br><span class="line">            <span class="keyword">while</span>(delay)&#123;</span><br><span class="line">                delay--;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt--;</span><br><span class="line">            buffer[cnt] = <span class="number">0</span>;</span><br><span class="line">            mutex.<span class="built_in">V</span>();</span><br><span class="line">            empty_slots.<span class="built_in">V</span>(); <span class="comment">// 通知consumer缓冲区有资源可以取走</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consumerd an item, cnt = %d\n&quot;</span>,cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;underflow\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Assignment3"><a href="#Assignment3" class="headerlink" title="Assignment3"></a><strong>Assignment3</strong></h3><p>3.2-solution1</p>
<p>num初始化为4，在拿起筷子前num.P(),放下筷子之后num.V()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Semaphore eaters;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> delay =<span class="number">0xffffff</span>;</span><br><span class="line">        num.<span class="built_in">P</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher%d is hungry    &quot;</span>,id);</span><br><span class="line">  </span><br><span class="line">        chopsticks[id].<span class="built_in">P</span>();</span><br><span class="line">        <span class="keyword">while</span>(delay&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            delay--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//printf(&quot;philosopher%d picked up chopstick%d\n&quot;,id,id);</span></span><br><span class="line">        chopsticks[(id+<span class="number">1</span>)%MAX_SIZE].<span class="built_in">P</span>();</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//printf(&quot;philosopher%d picked up chopstick%d\n&quot;,id,(id+1)%MAX_SIZE);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;philosopher%d is eating\n&quot;</span>,id);</span><br><span class="line">        chopsticks[(id+<span class="number">1</span>)%MAX_SIZE].<span class="built_in">V</span>();</span><br><span class="line">        <span class="comment">//printf(&quot;philosopher%d lowered chopstick%d\n&quot;,id,id);</span></span><br><span class="line">        chopsticks[id].<span class="built_in">V</span>();</span><br><span class="line">        num.<span class="built_in">V</span>();</span><br><span class="line">        <span class="comment">//printf(&quot;philosopher%d lowered chopstick%d\n&quot;,id,(id+1)%MAX_SIZE);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.2-solution2</p>
<p>mutex-&gt;counter初始化为1，保证一个哲学家左右两根筷子都会被拿起</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mutex.<span class="built_in">P</span>();</span><br><span class="line">       chopsticks[id].<span class="built_in">P</span>();</span><br><span class="line">       <span class="keyword">while</span>(delay&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           delay--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//printf(&quot;philosopher%d picked up chopstick%d\n&quot;,id,id);</span></span><br><span class="line">       chopsticks[(id+<span class="number">1</span>)%MAX_SIZE].<span class="built_in">P</span>();</span><br><span class="line">       mutex.<span class="built_in">V</span>();</span><br></pre></td></tr></table></figure>

<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. <strong>实验结果</strong></h2><h3 id="Assignment1-代码复现题"><a href="#Assignment1-代码复现题" class="headerlink" title="Assignment1 代码复现题"></a><strong>Assignment1 代码复现题</strong></h3><p>1.1.1使用自旋锁解决消失的芝士汉堡问题</p>
<p>1.1.2使用信号量解决消失的芝士汉堡问题</p>
<p><img src="/2024/05/06/oslab6/oslab6/1714983997122.png" alt="1714983997122"></p>
<p>1.2使用bts实现自旋锁</p>
<p><img src="/2024/05/06/oslab6/oslab6/1716042645677.png" alt="1716042645677"></p>
<h3 id="Assignment2-生产者-消费者问题"><a href="#Assignment2-生产者-消费者问题" class="headerlink" title="Assignment2 生产者-消费者问题"></a><strong>Assignment2 生产者-消费者问题</strong></h3><p>2.1Race Condition</p>
<p><img src="/2024/05/06/oslab6/oslab6/1715744966610.png" alt="1715744966610"></p>
<p>2.2采用信号量的解决方案MAX_SIZE &#x3D; 1时</p>
<p><img src="/2024/05/06/oslab6/oslab6/1716042964914.png" alt="1716042964914"></p>
<h3 id="Assignment3-哲学家就餐问题"><a href="#Assignment3-哲学家就餐问题" class="headerlink" title="Assignment3 哲学家就餐问题"></a><strong>Assignment3 哲学家就餐问题</strong></h3><p>出现死锁情况：</p>
<p><img src="/2024/05/06/oslab6/oslab6/1715774700068.png" alt="1715774700068"></p>
<p>避免死锁情况：</p>
<p><img src="/2024/05/06/oslab6/oslab6/1716035988152.png" alt="1716035988152"></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h2><p>在这次实验中通过改变几个经典同步问题，我学习了自旋锁的实现，信号量的使用等基本知识，进一步了解了互斥访问的问题，使用SpinLock和信号量来给出实现线程互斥的解决方案。加深了对理论课知识的理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/22/oslab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/22/oslab5/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-22 11:06:50" itemprop="dateCreated datePublished" datetime="2024-04-22T11:06:50+08:00">2024-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-06 11:09:22" itemprop="dateModified" datetime="2024-05-06T11:09:22+08:00">2024-05-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>title:SYSU-2024操作系统lab3实验报告</p>
<p>date:2024-04-28 23:54:26</p>
<p>tags:os</p>
<p>comments:true</p>
<h2 id="author-zyh"><a href="#author-zyh" class="headerlink" title="author:zyh"></a>author:zyh</h2><h1 id="实验名称-Lab5-内核线程"><a href="#实验名称-Lab5-内核线程" class="headerlink" title="实验名称:          Lab5 内核线程"></a>实验名称:          Lab5 内核线程</h1><p>学生姓名:                    庄云皓</p>
<p>学生学号:                   22336327</p>
<p>实验成绩:</p>
<p>报告时间:                   2023-5-5</p>
<h2 id="1-实验要求"><a href="#1-实验要求" class="headerlink" title="1. 实验要求"></a>1. <strong>实验要求</strong></h2><h3 id="Assignment-1-printf的实现"><a href="#Assignment-1-printf的实现" class="headerlink" title="Assignment 1 printf的实现"></a>Assignment 1 printf的实现</h3><p>学习可变参数机制，然后实现printf，你可以在材料中的printf上进行改进，或者从头开始实现自己的printf函数。结果截图并说说你是怎么做的。</p>
<h3 id="Assignment-2-线程的实现"><a href="#Assignment-2-线程的实现" class="headerlink" title="Assignment 2 线程的实现"></a>Assignment 2 线程的实现</h3><p>自行设计PCB，可以添加更多的属性，如优先级等，然后根据你的PCB来实现线程，演示执行结果。</p>
<h3 id="Assignment-3-线程调度切换的秘密"><a href="#Assignment-3-线程调度切换的秘密" class="headerlink" title="Assignment 3 线程调度切换的秘密"></a>Assignment 3 线程调度切换的秘密</h3><p>操作系统的线程能够并发执行的秘密在于我们需要中断线程的执行，保存当前线程的状态，然后调度下一个线程上处理机，最后使被调度上处理机的线程从之前被中断点处恢复执行。现在，同学们可以亲手揭开这个秘密。</p>
<p>编写若干个线程函数，使用gdb跟踪 <code>c_time_interrupt_handler</code>、<code>asm_switch_thread</code>等函数，观察线程切换前后栈、寄存器、PC等变化，结合gdb、材料中“线程的调度”的内容来跟踪并说明下面两个过程。</p>
<ul>
<li>一个新创建的线程是如何被调度然后开始执行的。</li>
<li>一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理机后又是如何从被中断点开始执行的。</li>
</ul>
<p>通过上面这个练习，同学们应该能够进一步理解操作系统是如何实现线程的并发执行的。</p>
<h3 id="（必做与选做）Assignment-4-调度算法的实现"><a href="#（必做与选做）Assignment-4-调度算法的实现" class="headerlink" title="（必做与选做）Assignment 4 调度算法的实现"></a>（必做与选做）Assignment 4 调度算法的实现</h3><p>在材料中，我们已经学习了如何使用时间片轮转算法来实现线程调度。但线程调度算法不止一种，例如</p>
<ul>
<li>先来先服务。</li>
<li>最短作业（进程）优先。</li>
<li>响应比最高者优先算法。</li>
<li>优先级调度算法。</li>
<li>多级反馈队列调度算法。</li>
</ul>
<p>此外，我们的调度算法还可以是抢占式的。</p>
<p>现在，同学们需要将线程调度算法修改为上面提到的算法或者是同学们自己设计的算法。然后，同学们需要自行编写测试样例来呈现你的算法实现的正确性和基本逻辑。最后，将结果截图并说说你是怎么做的。<strong>（先来先服务为必做，其他为选做）</strong></p>
<p>参考资料：<a href="https://gitee.com/link?target=https://zhuanlan.zhihu.com/p/97071815">https://zhuanlan.zhihu.com/p/97071815</a></p>
<p>Tips：</p>
<ul>
<li>先来先服务最简单。</li>
<li>有些调度算法的实现<strong>可能需要</strong>用到中断。</li>
</ul>
<h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2. 实验过程"></a>2. <strong>实验过程</strong></h2><h3 id="Assignment-1"><a href="#Assignment-1" class="headerlink" title="Assignment 1"></a>Assignment 1</h3><h4 id="1-1可变参数机制"><a href="#1-1可变参数机制" class="headerlink" title="1.1可变参数机制"></a>1.1可变参数机制</h4><p>实现这些宏</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>va_list</code></td>
<td>定义一个指向可变参数列表的指针。</td>
</tr>
<tr>
<td><code>void va_start(va_list ap, last_arg)</code></td>
<td>初始化可变参数列表指针 <code>ap</code>，使其指向可变参数列表的起始位置，即函数的固定参数列表的最后一个参数 <code>last_arg</code>的后面第一个参数。</td>
</tr>
<tr>
<td><code>type va_arg(va_list ap, type)</code></td>
<td>以类型 <code>type</code>返回可变参数，并使 <code>ap</code>指向下一个参数。</td>
</tr>
<tr>
<td><code>void va_end(va_list ap)</code></td>
<td>清零 <code>ap</code>。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *va_list;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n) ((sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, v) (ap = (va_list)&amp;v + _INTSIZEOF(v))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, type) (*(type *)((ap += _INTSIZEOF(type)) - _INTSIZEOF(type)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap = (va_list)0)</span></span><br></pre></td></tr></table></figure>

<p>注意这里的 _INTSIZIOF: ~(sizeof(int) - 1)为0xfffffffc ,任何地址与它&amp;后将低两位清零，为了实现向上对齐，我们需要先加上(sizeof(int)-1)后再和0xfffffffc相与，此时得到的结果就是向上4字节对齐的。</p>
<h4 id="1-2-实现printf增加-b和-f功能"><a href="#1-2-实现printf增加-b和-f功能" class="headerlink" title="1.2 实现printf增加%b和%f功能"></a>1.2 实现printf增加%b和%f功能</h4><p>实现了print(“%b,n),j和print(“%f”,n),分别将i以2进制和float浮点数，保留六位小数输出</p>
<p>让我们先解释一下printf实现的过程，我们需要用到可变参数机制，</p>
<p>解释一下printf中的代码：</p>
<p>如果 % 的下一个字符是’\0’，则退出；如果是’c’，则以字符的格式返回一个可变参数列表中的参数，并将其加入缓冲区；如果是’s’，则输出并清空缓冲区，并以char*的格式返回一个可变参数列表中的参数，并直接打印；如果是’d’，则以int的格式返回一个可变参数列表中的参数，转换为字符串后加入缓冲区；如果是’x’，则以int的格式返回一个可变参数列表中的参数，进行进制转换，然后转换为字符串，加入缓冲区；</p>
<p>%b的实现只需把%x中的itos(number, temp, (fmt[i] &#x3D;&#x3D; ‘d’ ? 10 : 16));改成itos(number, temp, (fmt[i] &#x3D;&#x3D; ‘d’ ? 10 : 2));</p>
<p>%f的实现参考了<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44078824/article/details/118440458">printf的实现</a></p>
<p>简单地说，先把浮点数分成整数部分和小数部分，然后将整数和小数分别转换为单个字符打印。因为是保留六位小数，小数先*1000000再按整数方式来打印，具体代码见关键代码部分</p>
<p>测试一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;print percentage: %%\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print char \&quot;N\&quot;: %c\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print string \&quot;Hello World!\&quot;: %s\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print decimal: \&quot;-1234\&quot;: %d\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print hexadecimal \&quot;0x7abcdef0\&quot;: %x\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print binary \&quot;0b10\&quot;: %b\n&quot;</span></span><br><span class="line">           <span class="string">&quot;print float \&quot;3.1415\&quot;: %f\n&quot;</span>,</span><br><span class="line">           <span class="string">&#x27;N&#x27;</span>, <span class="string">&quot;Hello World!&quot;</span>, <span class="number">-1234</span>, <span class="number">0x7abcdef0</span>, <span class="number">0b10</span>,<span class="number">3.1415</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Assignment-2"><a href="#Assignment-2" class="headerlink" title="Assignment 2"></a>Assignment 2</h3><h4 id="线程的描述"><a href="#线程的描述" class="headerlink" title="线程的描述"></a>线程的描述</h4><p>先介绍一下进程控制块PCB:</p>
<p>在实验中用一个结构体表示，包括栈指针，线程名，状态，优先级，线程id等内容</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PCB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *stack;                      <span class="comment">// 栈指针，用于调度时保存esp</span></span><br><span class="line">    <span class="type">char</span> name[MAX_PROGRAM_NAME + <span class="number">1</span>]; <span class="comment">// 线程名</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">ProgramStatus</span> status;       <span class="comment">// 线程的状态</span></span><br><span class="line">    <span class="type">int</span> priority;                    <span class="comment">// 线程优先级</span></span><br><span class="line">    <span class="type">int</span> pid;                         <span class="comment">// 线程pid</span></span><br><span class="line">    <span class="type">int</span> ticks;                       <span class="comment">// 线程时间片总时间</span></span><br><span class="line">    <span class="type">int</span> ticksPassedBy;               <span class="comment">// 线程已执行时间</span></span><br><span class="line">    ListItem tagInGeneralList;       <span class="comment">// 线程队列标识</span></span><br><span class="line">    ListItem tagInAllList;           <span class="comment">// 线程队列标识</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解释几个变量的含义：<br>ticks是线程剩余的执行次数。在时间片调度算法中，每发生中断一次记为一个tick，当ticks&#x3D;0时，线程会被换下处理器，然后将其他线程换上处理器执行。</p>
<p>ticksPassedBy是线程总共执行的tick的次数。</p>
<p>tagInGeneralList和tagInAllList是线程在线程队列中的标识，用于在线程队列中找到线程的PCB。这两个变量的lListItem类型表示队列中的一个元素，是一个结构体，结构体中两个指针变量分别指向前面和后面的元素。用链表来实现进程队列，链表结构详见 ‘include&#x2F;list.h’</p>
<p>stack线程栈表示如下</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714812925884.png" alt="1714812925884"></p>
<p>对许多线程管理我们需要声明一个声明一个程序管理类 <code>ProgramManager.</code></p>
<p>用于线程和进程的创建和管理，代码见 <code>include/program.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROGRAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROGRAM_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProgramManager</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="线程的创建："><a href="#线程的创建：" class="headerlink" title="线程的创建："></a>线程的创建：</h4><p>1.我们在 <code>include/program.h</code>中对程序管理类 <code>ProgramManager</code>中的变量和函数进行声明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProgramManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    List allPrograms;   <span class="comment">// 所有状态的线程/进程的队列</span></span><br><span class="line">    List readyPrograms; <span class="comment">// 处于ready(就绪态)的线程/进程的队列</span></span><br><span class="line">    PCB *running;       <span class="comment">// 当前执行的线程</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProgramManager</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程并放入就绪队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// function：线程执行的函数</span></span><br><span class="line">    <span class="comment">// parameter：指向函数的参数的指针</span></span><br><span class="line">    <span class="comment">// name：线程的名称</span></span><br><span class="line">    <span class="comment">// priority：线程的优先级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功，返回pid；失败，返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">executeThread</span><span class="params">(ThreadFunction function, <span class="type">void</span> *parameter, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> priority)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个PCB</span></span><br><span class="line">    <span class="function">PCB *<span class="title">allocatePCB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 归还一个PCB</span></span><br><span class="line">    <span class="comment">// program：待释放的PCB</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">releasePCB</span><span class="params">(PCB *program)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行线程调度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">schedule</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zu se huan xing</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MESA_WakeUp</span><span class="params">(PCB *program)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">program_exit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.向内存申请PCB空间（以下内容见src&#x2F;kernel&#x2F;program.cpp)</p>
<p>（1）声明PCB的空间和PCB分配状态数组</p>
<p>在内存中开辟一个PCB_SIZE * MAX_PROGRAM_AMOUNT个字节的空间用于分配给所有线程的thread-&gt;stack。这里我们把PCB大小设置为4096（4kb)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> PCB_SET[PCB_SIZE * MAX_PROGRAM_AMOUNT];<span class="comment">//MAX_PROGRAM_AMOUNT个PCB的大小空间</span></span><br></pre></td></tr></table></figure>

<p>再用一个bool类型数组表示PCB分配状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PCB的分配状态，true表示已经分配，false表示未分配。</span></span><br><span class="line"><span class="type">bool</span> PCB_SET_STATUS[MAX_PROGRAM_AMOUNT];   </span><br></pre></td></tr></table></figure>

<p>如果已经给一个线程分配了PCB则将该线程对应的PCB_SET_STATUS中的数置1</p>
<p>（2）allocatePCB和releasePCB</p>
<p>具体进行分配的过程我们通过program_manager中的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个PCB</span></span><br><span class="line"><span class="function">PCB *<span class="title">allocatePCB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 归还一个PCB</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">releasePCB</span><span class="params">(PCB *program)</span></span>;</span><br></pre></td></tr></table></figure>

<p>来实现。两个函数实现的代码放置在 <code>src/kernel/program.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PCB *<span class="title">ProgramManager::allocatePCB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PROGRAM_AMOUNT; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PCB_SET_STATUS[i])</span><br><span class="line">        &#123;</span><br><span class="line">            PCB_SET_STATUS[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> (PCB *)((<span class="type">int</span>)PCB_SET + PCB_SIZE * i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数对PCB_SET_STATUS中的元素依次判断看该位置对应的PCB_SET空间是否已经被类配了，如果没有没有则返回第i个PCB的起始地址（对于第𝑖个PCB，<code>PCB_SET</code>的首地址加上<strong>i</strong>×<strong>P</strong>C<strong>B</strong>S<strong>I</strong>Z<strong>E</strong>𝑖×𝑃𝐶𝐵𝑆𝐼𝑍𝐸就是第<strong>i</strong>𝑖个PCB的起始地址）</p>
<p>有PCB的分配就有PCB的释放，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProgramManager::releasePCB</span><span class="params">(PCB *program)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index = ((<span class="type">int</span>)program - (<span class="type">int</span>)PCB_SET) / PCB_SIZE;</span><br><span class="line">    PCB_SET_STATUS[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>releasePCB</code>接受一个PCB指针 <code>program</code>，然后计算出 <code>program</code>指向的PCB在 <code>PCB_SET</code>中的位置，然后将 <code>PCB_SET_STATUS</code>中的对应位置设置 <code>false</code>即可。</p>
<p>（3）excuteThread的实现</p>
<p>在这里我们规定线程只能执行返回值为void，参数为void *的函数<br>我们在include&#x2F;Program.h中将上面提到的这个函数定义为ThreadFunction。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*ThreadFunction)</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在ProgramManager类中声明一个用于创建线程的函数executeThread：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 创建一个线程并放入就绪队列</span></span><br><span class="line">    <span class="comment">// function：线程执行的函数</span></span><br><span class="line">    <span class="comment">// parameter：指向函数的参数的指针</span></span><br><span class="line">    <span class="comment">// name：线程的名称</span></span><br><span class="line">    <span class="comment">// priority：线程的优先级</span></span><br><span class="line">    <span class="comment">// 成功，返回pid；失败，返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">executeThread</span><span class="params">(ThreadFunction function, <span class="type">void</span> *parameter, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>我们在src&#x2F;kernel&#x2F;program.cpp中实现executeThread，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ProgramManager::executeThread</span><span class="params">(ThreadFunction function, <span class="type">void</span> *parameter, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> priority)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 关中断，防止创建线程的过程被打断</span></span><br><span class="line">    <span class="type">bool</span> status = interruptManager.<span class="built_in">getInterruptStatus</span>();</span><br><span class="line">    interruptManager.<span class="built_in">disableInterrupt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一页作为PCB</span></span><br><span class="line">    PCB *thread = <span class="built_in">allocatePCB</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!thread)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化分配的页</span></span><br><span class="line">    <span class="built_in">memset</span>(thread, <span class="number">0</span>, PCB_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_PROGRAM_NAME &amp;&amp; name[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        thread-&gt;name[i] = name[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread-&gt;status = ProgramStatus::READY;</span><br><span class="line">    thread-&gt;priority = priority;</span><br><span class="line">    thread-&gt;ticks = priority * <span class="number">10</span>;</span><br><span class="line">    thread-&gt;ticksPassedBy = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;pid = ((<span class="type">int</span>)thread - (<span class="type">int</span>)PCB_SET) / PCB_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程栈</span></span><br><span class="line">    thread-&gt;stack = (<span class="type">int</span> *)((<span class="type">int</span>)thread + PCB_SIZE);</span><br><span class="line">    thread-&gt;stack -= <span class="number">7</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    thread-&gt;stack[<span class="number">4</span>] = (<span class="type">int</span>)function;</span><br><span class="line">    thread-&gt;stack[<span class="number">5</span>] = (<span class="type">int</span>)program_exit;</span><br><span class="line">    thread-&gt;stack[<span class="number">6</span>] = (<span class="type">int</span>)parameter;</span><br><span class="line"></span><br><span class="line">    allPrograms.<span class="built_in">push_back</span>(&amp;(thread-&gt;tagInAllList));</span><br><span class="line">    readyPrograms.<span class="built_in">push_back</span>(&amp;(thread-&gt;tagInGeneralList));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复中断</span></span><br><span class="line">    interruptManager.<span class="built_in">setInterruptStatus</span>(status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thread-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在逐步地分析线程创建的逻辑。</p>
<p>（1）关中断</p>
<p>3-5行保存中断状态然后关中断，诸如PCB分配的工作实际上都需要进行线程互斥处理，我们在这里使用开关中断实现线程互斥为什么开&#x2F;关中断有效呢？在后面可以看到，我们是在时钟中断发生时来进行线程调度的，因此关中断后，时钟中断无法被响应，线程就无法被调度，直到再次开中断。只要线程无法被调度，那么线程的工作也就无法被其他线程打断，因此就实现了线程互斥。</p>
<p>关中断后，我们需要在函数返回前，也就是第44行恢复中断。</p>
<p>开&#x2F;关中断等相关的的函数定义在 <code>include/interrupt.h</code>中，如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterruptManager</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开中断</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">enableInterrupt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关中断</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disableInterrupt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取中断状态</span></span><br><span class="line">    <span class="comment">// 返回true，中断开启；返回false，中断关闭</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getInterruptStatus</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 设置中断状态</span></span><br><span class="line">    <span class="comment">// status=true，开中断；status=false，关中断</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setInterruptStatus</span><span class="params">(<span class="type">bool</span> status)</span></span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数的实现比较简单，放置在 <code>src/interrupt/interrupt.cpp</code>中，这里便不再赘述，现在我们回到 <code>executeThread</code>。</p>
<p>（2）申请PCB空间，对PCB中的内容进行初始化</p>
<p>第8行，关中断后，我们向 <code>PCB_SET</code>申请一个线程的PCB，然后我们在第14行使用 <code>memeset</code>将PCB清0。<code>memeset</code>的声明和定义分别在 <code>include/stdlib.h</code>和 <code>src/utils/stdlib.cpp</code>。</p>
<p>第16-25行，我们设置PCB的成员 <code>name</code>、<code>status</code>、<code>priority</code>、<code>ticks</code>、<code>ticksPassedBy</code>和 <code>pid</code>。这里，线程初始的 <code>ticks</code>我们简单地设置为 <code>10</code>倍的 <code>priority</code>。<code>pid</code>则简单地使用PCB在 <code>PCB_SET</code>的位置来代替。</p>
<p>第28行，我们初始化线程的栈。我们将栈放置在PCB中，而线程的栈是从PCB的顶部开始向下增长的，所以不会与位于PCB低地址的 <code>name</code>和 <code>pid</code>等变量冲突。线程栈的初始地址是PCB的起始地址加上 <code>PCB_SIZE</code>。</p>
<p>第29-36行，我们在栈中放入7个整数值。</p>
<ul>
<li>4个为0的值是要放到ebp，ebx，edi，esi中的。</li>
<li><code>thread-&gt;stack[4]</code>是线程执行的函数的起始地址。</li>
<li><code>thread-&gt;stack[5]</code>是线程的返回地址，所有的线程执行完毕后都会返回到这个地址。</li>
<li><code>thread-&gt;stack[6]</code>是线程的参数的地址。</li>
</ul>
<p>至于这4部份的作用我们在线程的调度中统一讲解。</p>
<p>（3）将线程放进 <code>allPrograms</code>和 <code>readyPrograms</code></p>
<p>创建完线程的PCB后，我们将其放入到 <code>allPrograms</code>和 <code>readyPrograms</code>中，等待时钟中断来的时候，这个新创建的线程就可以被调度上处理器。</p>
<p>（4)开中断</p>
<p>最后我们将中断的状态恢复，此时我们便创建了一个线程。</p>
<h3 id="Assignment-3"><a href="#Assignment-3" class="headerlink" title="Assignment 3"></a>Assignment 3</h3><h4 id="3-1一个新创建的线程是如何被调度然后开始执行"><a href="#3-1一个新创建的线程是如何被调度然后开始执行" class="headerlink" title="3.1一个新创建的线程是如何被调度然后开始执行?"></a>3.1一个新创建的线程是如何被调度然后开始执行?</h4><p>我们来看setup.cpp中调用的汇编函数asm_switch_thread(0, firstThread);<br>将参数和返回地址压栈后，我们将 <code>ebp</code>，<code>ebx</code>，<code>edi</code>，<code>esi</code> 依次压栈（因为这几个存器的值可能会在被调函数中被修改，要先保护起来）。现在的栈状态如下：</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714905739957.png" alt="1714905739957"></p>
<p>29行[esp+5 * 4]表示PCB * cur这个指针变量的值（也就是指向空间的地址），把它赋值给eax。32行[esp+6 * 4]则是PCB *next.</p>
<p>注意30行保存当前栈指针esp到PCB::stack中.[eax]就是PCB * cur这个指针变量的值, 因为PCB第一个变量就是int <em><em>stack,[eax]其实就是</em>PCB::stack所在地址(int*)((int)thread+PCB_SIZE)-7</em></p>
<p><em>下面32-33行我们将PCB</em> next值写入eax,将next-&gt;stack的值写入esp<br>也就是说，现在esp由原来线程的stack切换为了next-&gt;stack.</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714908742419.png" alt="1714908742419"></p>
<p>通过调试过程来具体观察一下：<br>初始时esp为0x7bc0,</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714840614902.png" alt="1714840614902"></p>
<p>33行之后，可以看到esp的值变成了thread1的stack的地址,接着36行到39行弹出thread1的栈中内容（全都是0）到四个寄存器中。因为现在的esp已经变成了thread1的stack,返回地址也是函数first_thread的首地址。ret执行后就跳转到了first_thread函数。（如下图所示，先pop4个0到寄存器，然后返回，返回地址是function的地址）</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714909688608.png" alt="1714909688608"><br><img src="/2024/04/22/oslab5/oslab5/1714909446513.png" alt="1714909446513"><br>然后我们便进入了first_thread<br><img src="/2024/04/22/oslab5/oslab5/1714909863122.png" alt="1714909863122"></p>
<h4 id="3-2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的"><a href="#3-2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的" class="headerlink" title="3.2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的?"></a>3.2一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理器后又是如何从被中断点开始执行的?</h4><p>现在我们着重关注RR时间片轮转调度的过程，首先在中断处理函数处设置断点：</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714910381025.png" alt="1714910381025"></p>
<p>观察cur-&gt;ticks和cur-&gt;ticksPassedBy的变化<br><img src="/2024/04/22/oslab5/oslab5/1714910209537.png" alt="1714910209537"></p>
<p>每一次发生时钟中断时，中断处理函数都会将当前进程PCB的ticks-1,ticksPassedBy+1,当cur-&gt;ticks为0时进行进程切换。</p>
<p>接下来我们观察这个进程如何被换下处理器。时间片用完后进行调度，进入schedule函数内部，因为当前进程还在运行，我们把它放在ready队列的队尾，并将ticks重置。</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714911275547.png" alt="1714911275547"></p>
<p>接着获取ready队列的头一个元素，简单做一些变量的修改后，把ready队列头pop出来，接着我们又进入了asm_swith_thread(cur,next)</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714911725209.png" alt="1714911725209"></p>
<p>进行线程栈的切换，ret后返回second_thread.</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714912484030.png" alt="1714912484030"></p>
<p>thread1已经被换下处理器了，thread1下一次被换上处理器是具体如何执行的呢?</p>
<p>thread3的时间片用完以后，进入scedule函数，调用asm_swith_thread(cur,next),此时的next指向的是thread1,因为thread1已经不是新的进程了，此时它的ebp不为0.</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714913439195.png" alt="1714913439195"></p>
<p>注意到，这里函数返回地址132695是schedule函数中调用asm_swith_thread(cur,next)语句的地址，调用完该函数后返回原来位置。然后schedule函数执行完，继续执行完他所在的c_time_interrupt_handle后返回asm_time_interrupt_handle，该函数iret后返回了thread1执行到的位置，也就是asm_halt中的死循环。</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714913635709.png" alt="1714913635709"></p>
<p><img src="/2024/04/22/oslab5/oslab5/1714914114783.png" alt="1714914114783"></p>
<h3 id="Assignment-4"><a href="#Assignment-4" class="headerlink" title="Assignment 4"></a>Assignment 4</h3><p>4.1FIFO</p>
<p>相比于assignment23修改了：</p>
<p>c_time_interrupt_handler()中把队cur-&gt;ticks的处理全都去掉</p>
<p>线程都没有死循环</p>
<p>void program_exit()中如果ready队列非空则进行调度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!programManager.readyPrograms.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    programManager.<span class="built_in">schedule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果见实验结果</p>
<p>4.1优先级调度</p>
<p>在ProgramManager::schedule()函数中找当前ready队列优先级最大的任务，具体代码见关键代码部分</p>
<p>将thread1,2,3的优先级分别设置为1,2,3,那么会依次执行thread3,2,1,结果见实验结果部分</p>
<h2 id="3-关键代码"><a href="#3-关键代码" class="headerlink" title="3. 关键代码"></a>3. <strong>关键代码</strong></h2><h3 id="Assignment1"><a href="#Assignment1" class="headerlink" title="Assignment1"></a>Assignment1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// 接收浮点型 保留6为小数，不采取四舍五入</span></span><br><span class="line">                <span class="type">float</span> ArgFloVal = <span class="built_in">va_arg</span>(ap, <span class="type">double</span>);</span><br><span class="line">                <span class="keyword">if</span> (ArgFloVal &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, <span class="string">&#x27;-&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    ArgFloVal = -ArgFloVal;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> val_seg = (<span class="type">unsigned</span> <span class="type">long</span>)ArgFloVal;<span class="comment">// 取整数部分</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> val_temp = val_seg;      <span class="comment">// 临时保存整数部分数据</span></span><br><span class="line">                ArgFloVal = ArgFloVal - val_seg;<span class="comment">// 得出余下的小数部分</span></span><br><span class="line">                <span class="comment">// 计算整数部分长度</span></span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (val_seg)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (val_seg) &#123;</span><br><span class="line">                        cnt++;</span><br><span class="line">                        val_seg /= <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt = <span class="number">1</span>;<span class="comment">// 数字0的长度为1</span></span><br><span class="line">                <span class="comment">//counter += cnt;// 字符个数加上整数的长度</span></span><br><span class="line">                <span class="comment">// 将整数转为单个字符打印</span></span><br><span class="line">                <span class="keyword">while</span> (cnt)</span><br><span class="line">                &#123;</span><br><span class="line">                    val_seg = val_temp / <span class="built_in">m_pow_n</span>(<span class="number">10</span>, cnt - <span class="number">1</span>);</span><br><span class="line">                    val_temp %= <span class="built_in">m_pow_n</span>(<span class="number">10</span>, cnt - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//my_send_char((char)val_seg + &#x27;0&#x27;);</span></span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, (<span class="type">char</span>)val_seg + <span class="string">&#x27;0&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印小数点</span></span><br><span class="line">                counter += <span class="built_in">printf_add_to_buffer</span>(buffer,<span class="string">&#x27;.&#x27;</span>, idx, BUF_LEN);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开始输出小数部分</span></span><br><span class="line">                ArgFloVal *= <span class="number">1000000</span>;</span><br><span class="line">                <span class="comment">// printf(&quot;\r\n %f\r\n&quot;, ArgFloVal);</span></span><br><span class="line">                cnt = <span class="number">6</span>;</span><br><span class="line">                val_temp = (<span class="type">int</span>)ArgFloVal;<span class="comment">// 取整数部分</span></span><br><span class="line">                <span class="keyword">while</span> (cnt)</span><br><span class="line">                &#123;</span><br><span class="line">                    val_seg = val_temp / <span class="built_in">m_pow_n</span>(<span class="number">10</span>, cnt - <span class="number">1</span>);</span><br><span class="line">                    val_temp %= <span class="built_in">m_pow_n</span>(<span class="number">10</span>, cnt - <span class="number">1</span>);</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, (<span class="type">char</span>)val_seg + <span class="string">&#x27;0&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    <span class="comment">//my_send_char((char)val_seg + &#x27;0&#x27;);</span></span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//ret_num += 6;</span></span><br><span class="line">                <span class="comment">//pStr++;</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:&#123;</span><br><span class="line">             <span class="type">int</span> temp = <span class="built_in">va_arg</span>(ap, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, <span class="string">&#x27;-&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    temp = -temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">itos</span>(number, temp, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; number[j]; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, number[j], idx, BUF_LEN);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:&#123;</span><br><span class="line">                <span class="type">int</span> temp = <span class="built_in">va_arg</span>(ap, <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (temp &lt; <span class="number">0</span> &amp;&amp; fmt[i] == <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, <span class="string">&#x27;-&#x27;</span>, idx, BUF_LEN);</span><br><span class="line">                    temp = -temp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">itos</span>(number, temp, (fmt[i] == <span class="string">&#x27;d&#x27;</span> ? <span class="number">10</span> : <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; number[j]; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    counter += <span class="built_in">printf_add_to_buffer</span>(buffer, number[j], idx, BUF_LEN);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Assignment3"><a href="#Assignment3" class="headerlink" title="Assignment3"></a>Assignment3</h3><p>代码的解释见实验过程部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">asm_switch_thread:</span><br><span class="line">    push ebp</span><br><span class="line">    push ebx</span><br><span class="line">    push edi</span><br><span class="line">    push esi</span><br><span class="line"></span><br><span class="line">    mov eax, [esp + 5 * 4]</span><br><span class="line">    mov [eax], esp ; 保存当前栈指针到PCB中，以便日后恢复</span><br><span class="line"></span><br><span class="line">    mov eax, [esp + 6 * 4]</span><br><span class="line">    mov esp, [eax] ; 此时栈已经从cur栈切换到next栈</span><br><span class="line"></span><br><span class="line">    pop esi</span><br><span class="line">    pop edi</span><br><span class="line">    pop ebx</span><br><span class="line">    pop ebp</span><br><span class="line"></span><br><span class="line">    sti</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<h3 id="Assignment-4-1"><a href="#Assignment-4-1" class="headerlink" title="Assignment 4"></a>Assignment 4</h3><p>优先级调度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProgramManager::schedule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> status = interruptManager.<span class="built_in">getInterruptStatus</span>();</span><br><span class="line">    interruptManager.<span class="built_in">disableInterrupt</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readyPrograms.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        interruptManager.<span class="built_in">setInterruptStatus</span>(status);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (running-&gt;status == ProgramStatus::RUNNING)</span><br><span class="line">    &#123;</span><br><span class="line">        running-&gt;status = ProgramStatus::READY;</span><br><span class="line">        running-&gt;ticks = running-&gt;priority * <span class="number">10</span>;</span><br><span class="line">        readyPrograms.<span class="built_in">push_back</span>(&amp;(running-&gt;tagInGeneralList));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (running-&gt;status == ProgramStatus::DEAD)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">releasePCB</span>(running);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化max,next,nextid,ready队列的size</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">    PCB* next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> nextid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = readyPrograms.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//找到优先级最大的线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        ListItem* item = readyPrograms.<span class="built_in">at</span>(i);</span><br><span class="line">        PCB* tmp = <span class="built_in">ListItem2PCB</span>(item, tagInGeneralList);</span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;priority &gt; max)&#123;</span><br><span class="line">            max = tmp-&gt;priority;</span><br><span class="line">            nextid = i;</span><br><span class="line">            next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ListItem *item = readyPrograms.front();</span></span><br><span class="line">    <span class="comment">//PCB *next = ListItem2PCB(item, tagInGeneralList);</span></span><br><span class="line">    <span class="comment">//从ready队列中取出，将该线程状态置为running</span></span><br><span class="line">    PCB *cur = running;</span><br><span class="line">    next-&gt;status = ProgramStatus::RUNNING;</span><br><span class="line">    running = next;</span><br><span class="line">    readyPrograms.<span class="built_in">erase</span>(nextid);</span><br><span class="line">    <span class="comment">//切换线程栈，实现线程的切换</span></span><br><span class="line">    <span class="built_in">asm_switch_thread</span>(cur, next);</span><br><span class="line"></span><br><span class="line">    interruptManager.<span class="built_in">setInterruptStatus</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. <strong>实验结果</strong></h2><h4 id="Assignment1-1"><a href="#Assignment1-1" class="headerlink" title="Assignment1:"></a>Assignment1:</h4><p>printf %b（二进制）和%f(保留六位小数)</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714908659141.png" alt="1714908659141"></p>
<h4 id="Assignment2"><a href="#Assignment2" class="headerlink" title="Assignment2:"></a>Assignment2:</h4><p><img src="/2024/04/22/oslab5/oslab5/1714919664301.png" alt="1714919664301"></p>
<h4 id="Assignment3-1"><a href="#Assignment3-1" class="headerlink" title="Assignment3:"></a>Assignment3:</h4><p>见实验过程部分</p>
<h4 id="Assignment4"><a href="#Assignment4" class="headerlink" title="Assignment4:"></a>Assignment4:</h4><p>4.1 FIFO</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714917101307.png" alt="1714917101307"></p>
<p>4.2 优先级调度</p>
<p><img src="/2024/04/22/oslab5/oslab5/1714917971082.png" alt="1714917971082"></p>
<h2 id="5-实验总结"><a href="#5-实验总结" class="headerlink" title="5.实验总结"></a>5.实验总结</h2><p>通过这次实验，学习了可变参数机制，并增添了实验中的pringf函数的功能，线程在操作系统中的描述，调度方式。复现实验很容易，但要深入理解其中的每一处细节并准确描述出来很难。我在Assignment3中开始由于对函数调用过程中栈的变化不熟悉卡了很久，后来看到其他同学的解释时才更加深入理解了 <code>asm_switch_thread</code>的设计,感受到了设计的巧妙之处。</p>
<!--在src/kernel/pragram.cpp文件中，传参为nullptr的作用？

为什么会返回schedule-->

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/07/oslab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/07/oslab3/" class="post-title-link" itemprop="url">SYSU-2024操作系统lab3实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-07 23:54:26" itemprop="dateCreated datePublished" datetime="2024-04-07T23:54:26+08:00">2024-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-08 10:15:13" itemprop="dateModified" datetime="2024-04-08T10:15:13+08:00">2024-04-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实验课程:					操作系统</p>
<h1 id="实验名称-Lab3-从实模式到保护模式"><a href="#实验名称-Lab3-从实模式到保护模式" class="headerlink" title="实验名称:          Lab3 从实模式到保护模式"></a>实验名称:          Lab3 从实模式到保护模式</h1><h2 id="1-实验要求"><a href="#1-实验要求" class="headerlink" title="1. 实验要求"></a>1. <strong>实验要求</strong></h2><h3 id="任务-1"><a href="#任务-1" class="headerlink" title="任务 1"></a>任务 1</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4><p>复现Example 1，说说你是怎么做的并提供结果截图，也可以参考Ucore、Xv6等系统源码，实现自己的LBA方式的磁盘访问。<br>提示：部分需要的文件存放在src&#x2F;example-1下，请根据需要将其放置于自己创建的lab3文件夹下。</p>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h4><p>在Example1中，我们使用了LBA28的方式来读取硬盘。此时，我们只要给出逻辑扇区号即可，但需要手动去读取I&#x2F;O端口。然而，BIOS提供了实模式下读取硬盘的中断，其不需要关心具体的I&#x2F;O端口，只需要给出逻辑扇区号对应的磁头（Heads）、扇区（Sectors）和柱面（Cylinder）即可，又被称为CHS模式。现在，同学们需要将LBA28读取硬盘的方式换成CHS读取，同时给出逻辑扇区号向CHS的转换公式。最后说说你是怎么做的并提供结果截图。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/04/07/oslab3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/24/oslab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/24/oslab2/" class="post-title-link" itemprop="url">SYSU-2024操作系统lab2实验</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-24 23:54:26" itemprop="dateCreated datePublished" datetime="2024-03-24T23:54:26+08:00">2024-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-07 22:15:33" itemprop="dateModified" datetime="2024-04-07T22:15:33+08:00">2024-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本科生实验报告</p>
<p>实验课程:					操作系统</p>
<h1 id="实验名称-Lab2-实验入门"><a href="#实验名称-Lab2-实验入门" class="headerlink" title="实验名称:          Lab2 实验入门"></a>实验名称:          Lab2 实验入门</h1><h2 id="1-实验要求"><a href="#1-实验要求" class="headerlink" title="1. 实验要求"></a>1. <strong>实验要求</strong></h2><h3 id="任务1："><a href="#任务1：" class="headerlink" title="任务1："></a><strong>任务1：</strong></h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a><strong>1.1</strong></h4><p>根据Example1教程，复现Example 1。</p>
<h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a><strong>1.2</strong></h4><p>修改Example 1的代码，使得MBR被加载到0x7C00后在(12,12)处开始输出你的学号。注意，学号显示的前景色和背景色必须和教程中不同。</p>
<h3 id="任务2："><a href="#任务2：" class="headerlink" title="任务2："></a><strong>任务2：</strong></h3><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a><strong>2.1</strong></h4><p>请探索实模式下的光标中断<strong>int 10h</strong>， 实现将光标移动至(8,8)，获取并输出光标的位置 。说说你是怎么做的，并将结果截图。</p>
<h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a><strong>2.2</strong></h4><p>利用实模式下的中断， <strong>从</strong>(8,8)开始输出你的学号 。说说你是怎么做的，并将结果截图。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/03/24/oslab2/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/23/image/assemble-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/23/image/assemble-learning/" class="post-title-link" itemprop="url">汇编学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-23 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-23T00:00:00+08:00">2024-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-05 23:11:25" itemprop="dateModified" datetime="2024-05-05T23:11:25+08:00">2024-05-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/2024/03/23/image/assemble-learning/%E6%B1%87%E7%BC%96/1711196825096.png" alt="1711196825096"></p>
<h1 id="常用的gdb调试指令"><a href="#常用的gdb调试指令" class="headerlink" title="常用的gdb调试指令"></a>常用的gdb调试指令</h1><table>
<thead>
<tr>
<th>gdb指令</th>
<th>含义</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>break *adress或b *address</td>
<td>在地址adress处设置断点。</td>
<td>break *0x7c00&#96;&#96;b *0x7c00</td>
</tr>
<tr>
<td>break symbol或b symbol</td>
<td>在符号symbol处设置断点，例如symbol一般是函数名。</td>
<td>break setup_kernel&#96;&#96;b setup_kernel</td>
</tr>
<tr>
<td>break filename:line_number</td>
<td>在文件filename处的第line_numer行设置断点</td>
<td>b mbr.asm:12</td>
</tr>
<tr>
<td>add-symbol-file filename address</td>
<td>加载符号表filename到地址address处</td>
<td>add-symbol-file mbr.symbol 0x7c00</td>
</tr>
<tr>
<td>x&#x2F;FMT address</td>
<td>address是内存地址，FMT格式是重复的单元个数+格式+大小。<br><code>重复的单元个数是一个数字，表示我们希望查看多少个单元。正数表示从address向后查看。负数表示从address向前查看。</code>格式是一个字符，可以是o(octal), x(hex), d(decimal), u(unsigned decimal), t(binary), f(float), a(address), i(instruction), c(char), s(string)。&#96;&#96;大小是一个字符，可以是b(byte, 1 byte), h(halfword, 2 byte), w(word, 4 byte), g(giant, 8 bytes)。</td>
<td>x&#x2F;5xw 0x8032&#96;&#96;x&#x2F;10i 0x7c00</td>
</tr>
<tr>
<td>continue或c</td>
<td>继续执行正在调试的程序到断点处暂停。</td>
<td></td>
</tr>
<tr>
<td>step或s</td>
<td>执行一条C语句，如果遇到函数调用语句，则会进入函数体中。</td>
<td></td>
</tr>
<tr>
<td>next或n</td>
<td>执行一条C语句，函数调用语句不会进入函数体，把函数当成一条语句执行。</td>
<td></td>
</tr>
<tr>
<td>stepi或si</td>
<td>执行一条汇编语句，如果遇到函数调用语句，则会进入函数体中。</td>
<td></td>
</tr>
<tr>
<td>nexti或ni</td>
<td>执行一条汇编语句，函数调用语句不会进入函数体，把函数当成一条语句执行。</td>
<td></td>
</tr>
<tr>
<td>info registers</td>
<td>查看所有寄存器的值</td>
<td></td>
</tr>
<tr>
<td>layout layout_name</td>
<td>layout_name包含src，asm，split，regs。&#96;&#96;src显示源代码窗口和命令窗口，asm显示汇编代码窗口和命令窗口，split显示源代码窗口、汇编代码窗口和命令窗口，regs显示寄存器窗口。</td>
<td>layout split</td>
</tr>
<tr>
<td>focus layout_window</td>
<td>转换当前窗口到layout窗口，layout_window包含src，asm，regs，cmd。任何时刻gdb的当前窗口只有一个，并且使用方向键的效果只会在当前窗口处显示。</td>
<td>focus cmd</td>
</tr>
<tr>
<td>file symbol_file</td>
<td>加载符号表，为gdb提供debug信息。</td>
<td>file ..&#x2F;build&#x2F;kernel.o</td>
</tr>
<tr>
<td>set disassembly-flavor intel</td>
<td>设置汇编代码格式为intel风格</td>
<td></td>
</tr>
<tr>
<td>set architecture name</td>
<td>设置指令对应的CPU架构，name包含i8086(16位)，i386(32位)</td>
<td>set architecture i386</td>
</tr>
</tbody></table>
<p>详解子程序调用过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">asm_switch_thread:</span><br><span class="line">    push ebp</span><br><span class="line">    push ebx</span><br><span class="line">    push edi</span><br><span class="line">    push esi</span><br><span class="line"></span><br><span class="line">    mov eax, [esp + 5 * 4]</span><br><span class="line">    mov [eax], esp ; 保存当前栈指针到PCB中，以便日后恢复</span><br><span class="line"></span><br><span class="line">    mov eax, [esp + 6 * 4]</span><br><span class="line">    mov esp, [eax] ; 此时栈已经从cur栈切换到next栈</span><br><span class="line"></span><br><span class="line">    pop esi</span><br><span class="line">    pop edi</span><br><span class="line">    pop ebx</span><br><span class="line">    pop ebp</span><br><span class="line"></span><br><span class="line">    sti</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>1.push指令</p>
<p>push %eax</p>
<p>将eax数值压入栈中，可分解为：</p>
<p>sub $4, %esp ——&gt; esp &#x3D; esp - 4</p>
<p>mov %eax, (%esp) ——&gt; *(int32_t *)esp &#x3D; eax</p>
<p>2.pop指令</p>
<p>pop %eax</p>
<p>将eax数值弹出栈，可分解为：</p>
<p>mov (%esp), %eax ——&gt; eax &#x3D; *(int32_t *)esp</p>
<p>add $4, %esp ——&gt; esp &#x3D; esp + 4</p>
<p>3.call指令</p>
<p>call 0x12345</p>
<p>调用0x12345这个地址，可分解为：</p>
<p>push %eip ——&gt; 将cpu下一条要执行的指令压入栈中</p>
<p>mov $0x12345, %eip ——&gt; eip &#x3D; 0x12345</p>
<p>注意：CPU下一条指令将会从地址0x12345中取。</p>
<p>4.ret指令</p>
<p>ret</p>
<p>返回call之前的地址，可分解为：</p>
<p>pop %eip ——&gt; 将call压入栈的指令弹出赋给eip</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/21/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/21/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-21 19:51:45" itemprop="dateCreated datePublished" datetime="2024-03-21T19:51:45+08:00">2024-03-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/10/oslab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zyh">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yhzhuang">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/10/oslab1/" class="post-title-link" itemprop="url">操作系统lab1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-10 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-10T00:00:00+08:00">2024-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-25 01:37:26" itemprop="dateModified" datetime="2024-03-25T01:37:26+08:00">2024-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<p>sf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfsf</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/10/oslab1/1711029383714.png" alt="1711029383714"></p>
<p><strong>本科生实验报告</strong></p>
<p>实验课程:					操作系统</p>
<h1 id="实验名称-lab1-编译内核-利用已有内核构建OS"><a href="#实验名称-lab1-编译内核-利用已有内核构建OS" class="headerlink" title="实验名称: lab1 编译内核&#x2F;利用已有内核构建OS"></a>实验名称: lab1 编译内核&#x2F;利用已有内核构建OS</h1><ol>
<li><strong>实验要求</strong></li>
</ol>
<p>独立完成实验5个部分 <strong>环境配置</strong> 、 <strong>编译****Linux内核</strong>、 <strong>Qemu启动内核并开启远程调试</strong> 、<strong>制作<strong><strong>Initramfs</strong></strong></strong>和 <strong>编译并启动</strong>Busybox**** 。</p>
<p>1.搭建OS内核开发环境包括：代码编辑环境、编译环境、运行环境、调试环境等。</p>
<p>2.下载并编译i386（32位）内核，并利用qemu启动内核。</p>
<p>3.熟悉制作initramfs的方法。</p>
<p>4.编写简单应用程序随内核启动运行。</p>
<p>5.编译i386版本的Busybox，随内核启动，构建简单的OS。</p>
<p>6.开启远程调试功能，进行调试跟踪代码运行。</p>
<p>7.撰写实验报告。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/03/10/oslab1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zyh</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zyh</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
